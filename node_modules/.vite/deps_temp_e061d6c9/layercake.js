import {
  linear,
  rgb,
  sqrt
} from "./chunk-T3X5Q4IP.js";
import {
  InternSet,
  ascending,
  bin
} from "./chunk-JVHKYPNP.js";
import {
  derived,
  writable
} from "./chunk-QXHVM272.js";
import "./chunk-2Z2XDZGU.js";
import {
  SvelteComponentDev,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  append_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  check_outros,
  component_subscribe,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  globals,
  group_outros,
  init,
  insert_dev,
  onMount,
  safe_not_equal,
  setContext,
  set_data_dev,
  set_store_value,
  set_style,
  space,
  svg_element,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-TD4GBMNX.js";
import {
  stack_default
} from "./chunk-WXBRLSYN.js";

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/utils/canBeZero.js
function canBeZero(val) {
  if (val === 0) {
    return true;
  }
  return val;
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/utils/makeAccessor.js
function makeAccessor(acc) {
  if (!canBeZero(acc))
    return null;
  if (Array.isArray(acc)) {
    return (d) => acc.map((k) => {
      return typeof k !== "function" ? d[k] : k(d);
    });
  } else if (typeof acc !== "function") {
    return (d) => d[acc];
  }
  return acc;
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/utils/filterObject.js
function filterObject(obj, comparisonObj = {}) {
  return Object.fromEntries(
    Object.entries(obj).filter(([key, value]) => {
      return value !== void 0 && comparisonObj[key] === void 0;
    })
  );
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/utils/debounce.js
function debounce(func, timeout = 300) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, timeout);
  };
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/lib/calcUniques.js
function calcUniques(data, fields, sortOptions = {}) {
  if (!Array.isArray(data)) {
    throw new TypeError(
      `The first argument of calcUniques() must be an array. You passed in a ${typeof data}. If you got this error using the <LayerCake> component, consider passing a flat array to the \`flatData\` prop. More info: https://layercake.graphics/guide/#flatdata`
    );
  }
  if (Array.isArray(fields) || fields === void 0 || fields === null) {
    throw new TypeError(
      "The second argument of calcUniques() must be an object with field names as keys as accessor functions as values."
    );
  }
  const uniques2 = {};
  const keys = Object.keys(fields);
  const kl = keys.length;
  let i;
  let j;
  let k;
  let s;
  let acc;
  let val;
  let set;
  const dl = data.length;
  for (i = 0; i < kl; i += 1) {
    set = new InternSet();
    s = keys[i];
    acc = fields[s];
    for (j = 0; j < dl; j += 1) {
      val = acc(data[j]);
      if (Array.isArray(val)) {
        const vl = val.length;
        for (k = 0; k < vl; k += 1) {
          set.add(val[k]);
        }
      } else {
        set.add(val);
      }
    }
    const results = Array.from(set);
    if (sortOptions.sort === true || sortOptions[s] === true) {
      results.sort(ascending);
    }
    uniques2[s] = results;
  }
  return uniques2;
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/lib/calcExtents.js
function calcExtents(data, fields) {
  if (!Array.isArray(data)) {
    throw new TypeError(
      `The first argument of calcExtents() must be an array. You passed in a ${typeof data}. If you got this error using the <LayerCake> component, consider passing a flat array to the \`flatData\` prop. More info: https://layercake.graphics/guide/#flatdata`
    );
  }
  if (Array.isArray(fields) || fields === void 0 || fields === null) {
    throw new TypeError(
      "The second argument of calcExtents() must be an object with field names as keys as accessor functions as values."
    );
  }
  const extents = {};
  const keys = Object.keys(fields);
  const kl = keys.length;
  let i;
  let j;
  let k;
  let s;
  let min;
  let max;
  let acc;
  let val;
  const dl = data.length;
  for (i = 0; i < kl; i += 1) {
    s = keys[i];
    acc = fields[s];
    min = null;
    max = null;
    for (j = 0; j < dl; j += 1) {
      val = acc(data[j], j);
      if (Array.isArray(val)) {
        const vl = val.length;
        for (k = 0; k < vl; k += 1) {
          if (val[k] !== false && val[k] !== void 0 && val[k] !== null && Number.isNaN(val[k]) === false) {
            if (min === null || val[k] < min) {
              min = val[k];
            }
            if (max === null || val[k] > max) {
              max = val[k];
            }
          }
        }
      } else if (val !== false && val !== void 0 && val !== null && Number.isNaN(val) === false) {
        if (min === null || val < min) {
          min = val;
        }
        if (max === null || val > max) {
          max = val;
        }
      }
    }
    extents[s] = [min, max];
  }
  return extents;
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/utils/arraysEqual.js
function arraysEqual(arr1, arr2) {
  if (arr1.length !== arr2.length)
    return false;
  return arr1.every((k) => {
    return arr2.includes(k);
  });
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/helpers/isOrdinalDomain.js
function isOrdinalDomain(scale) {
  if (typeof scale.bandwidth === "function") {
    return true;
  }
  if (arraysEqual(Object.keys(scale), ["domain", "range", "unknown", "copy"])) {
    return true;
  }
  return false;
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/helpers/calcScaleExtents.js
function calcScaleExtents(flatData, getters, activeScales) {
  const scaleGroups = Object.entries(activeScales).reduce(
    (groups, [k, scaleInfo]) => {
      const domainType = isOrdinalDomain(scaleInfo.scale) === true ? "ordinal" : "other";
      if (!groups[domainType])
        groups[domainType] = {};
      groups[domainType][k] = getters[k];
      return groups;
    },
    { ordinal: false, other: false }
  );
  let extents = {};
  if (scaleGroups.ordinal) {
    const sortOptions = Object.fromEntries(
      Object.entries(activeScales).map(([k, scaleInfo]) => {
        return [k, scaleInfo.sort];
      })
    );
    extents = calcUniques(flatData, scaleGroups.ordinal, sortOptions);
  }
  if (scaleGroups.other) {
    extents = { ...extents, ...calcExtents(flatData, scaleGroups.other) };
  }
  return extents;
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/utils/partialDomain.js
function partialDomain(domain = [], directive) {
  if (Array.isArray(directive) === true) {
    return directive.map((d, i) => {
      if (d === null) {
        return domain[i];
      }
      return d;
    });
  }
  return domain;
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/helpers/calcDomain.js
function calcDomain(s) {
  return function domainCalc([$extents, $domain]) {
    if (typeof $domain === "function") {
      $domain = $domain($extents[s]);
    }
    return $extents ? partialDomain($extents[s], $domain) : $domain;
  };
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/settings/defaultScales.js
var defaultScales_default = {
  x: linear,
  y: linear,
  z: linear,
  r: sqrt
};

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/helpers/findScaleType.js
function findScaleType(scale) {
  if (scale.constant) {
    return "symlog";
  }
  if (scale.base) {
    return "log";
  }
  if (scale.exponent) {
    if (scale.exponent() === 0.5) {
      return "sqrt";
    }
    return "pow";
  }
  return "other";
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/utils/identity.js
function identity(d) {
  return d;
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/helpers/getPadFunctions.js
function log(sign) {
  return (x) => Math.log(sign * x);
}
function exp(sign) {
  return (x) => sign * Math.exp(x);
}
function symlog(c) {
  return (x) => Math.sign(x) * Math.log1p(Math.abs(x / c));
}
function symexp(c) {
  return (x) => Math.sign(x) * Math.expm1(Math.abs(x)) * c;
}
function pow(exponent) {
  return function powFn(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}
function getPadFunctions(scale) {
  const scaleType = findScaleType(scale);
  if (scaleType === "log") {
    const sign = Math.sign(scale.domain()[0]);
    return { lift: log(sign), ground: exp(sign), scaleType };
  }
  if (scaleType === "pow") {
    const exponent = 1;
    return { lift: pow(exponent), ground: pow(1 / exponent), scaleType };
  }
  if (scaleType === "sqrt") {
    const exponent = 0.5;
    return { lift: pow(exponent), ground: pow(1 / exponent), scaleType };
  }
  if (scaleType === "symlog") {
    const constant = 1;
    return { lift: symlog(constant), ground: symexp(constant), scaleType };
  }
  return { lift: identity, ground: identity, scaleType };
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/helpers/toTitleCase.js
function toTitleCase(str) {
  return str.replace(/^\w/, (d) => d.toUpperCase());
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/helpers/findScaleName.js
function f(name, modifier = "") {
  return `scale${toTitleCase(modifier)}${toTitleCase(name)}`;
}
function findScaleName(scale) {
  if (typeof scale.bandwidth === "function") {
    if (typeof scale.paddingInner === "function") {
      return f("band");
    }
    return f("point");
  }
  if (arraysEqual(Object.keys(scale), ["domain", "range", "unknown", "copy"])) {
    return f("ordinal");
  }
  let modifier = "";
  if (scale.interpolator) {
    if (scale.domain().length === 3) {
      modifier = "diverging";
    } else {
      modifier = "sequential";
    }
  }
  if (scale.quantiles) {
    return f("quantile", modifier);
  }
  if (scale.thresholds) {
    return f("quantize", modifier);
  }
  if (scale.constant) {
    return f("symlog", modifier);
  }
  if (scale.base) {
    return f("log", modifier);
  }
  if (scale.exponent) {
    if (scale.exponent() === 0.5) {
      return f("sqrt", modifier);
    }
    return f("pow", modifier);
  }
  if (arraysEqual(Object.keys(scale), ["domain", "range", "invertExtent", "unknown", "copy"])) {
    return f("threshold");
  }
  if (arraysEqual(Object.keys(scale), [
    "invert",
    "range",
    "domain",
    "unknown",
    "copy",
    "ticks",
    "tickFormat",
    "nice"
  ])) {
    return f("identity");
  }
  if (arraysEqual(Object.keys(scale), [
    "invert",
    "domain",
    "range",
    "rangeRound",
    "round",
    "clamp",
    "unknown",
    "copy",
    "ticks",
    "tickFormat",
    "nice"
  ])) {
    return f("radial");
  }
  if (modifier) {
    return f(modifier);
  }
  if (scale.domain()[0] instanceof Date) {
    const d = /* @__PURE__ */ new Date();
    let s;
    d.getDay = () => s = "time";
    d.getUTCDay = () => s = "utc";
    scale.tickFormat(0, "%a")(d);
    return f(s);
  }
  return f("linear");
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/utils/padScale.js
var unpaddable = ["scaleThreshold", "scaleQuantile", "scaleQuantize", "scaleSequentialQuantile"];
function padScale(scale, padding) {
  if (typeof scale.range !== "function") {
    throw new Error("Scale method `range` must be a function");
  }
  if (typeof scale.domain !== "function") {
    throw new Error("Scale method `domain` must be a function");
  }
  if (!Array.isArray(padding) || unpaddable.includes(findScaleName(scale))) {
    return scale.domain();
  }
  if (isOrdinalDomain(scale) === true) {
    return scale.domain();
  }
  const { lift, ground } = getPadFunctions(scale);
  const d0 = scale.domain()[0];
  const isTime = Object.prototype.toString.call(d0) === "[object Date]";
  const [d1, d2] = scale.domain().map((d) => {
    return isTime ? lift(d.getTime()) : lift(d);
  });
  const [r1, r2] = scale.range();
  const paddingLeft = padding[0] || 0;
  const paddingRight = padding[1] || 0;
  const step = (d2 - d1) / (Math.abs(r2 - r1) - paddingLeft - paddingRight);
  return [d1 - paddingLeft * step, paddingRight * step + d2].map((d) => {
    return isTime ? ground(new Date(d)) : ground(d);
  });
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/settings/getDefaultRange.js
function calcBaseRange(s, width, height, reverse, percentRange) {
  let min;
  let max;
  if (percentRange === true) {
    min = 0;
    max = 100;
  } else {
    min = s === "r" ? 1 : 0;
    max = s === "y" ? height : s === "r" ? 25 : width;
  }
  return reverse === true ? [max, min] : [min, max];
}
function getDefaultRange(s, width, height, reverse, range, percentRange) {
  return !range ? calcBaseRange(s, width, height, reverse, percentRange) : typeof range === "function" ? range({ width, height }) : range;
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/helpers/createScale.js
function createScale(s) {
  return function scaleCreator([
    $scale,
    $extents,
    $domain,
    $padding,
    $nice,
    $reverse,
    $width,
    $height,
    $range,
    $percentScale
  ]) {
    if ($extents === null) {
      return null;
    }
    const defaultRange = getDefaultRange(s, $width, $height, $reverse, $range, $percentScale);
    const scale = $scale === defaultScales_default[s] ? $scale() : $scale.copy();
    scale.domain($domain);
    if (!scale.interpolator || typeof scale.interpolator === "function" && scale.interpolator().name.startsWith("identity")) {
      scale.range(defaultRange);
    }
    if ($padding) {
      scale.domain(padScale(scale, $padding));
    }
    if ($nice === true || typeof $nice === "number") {
      if (typeof scale.nice === "function") {
        scale.nice(typeof $nice === "number" ? $nice : void 0);
      } else {
        console.error(
          `[Layer Cake] You set \`${s}Nice: true\` but the ${s}Scale does not have a \`.nice\` method. Ignoring...`
        );
      }
    }
    return scale;
  };
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/helpers/createGetter.js
function createGetter([$acc, $scale]) {
  return (d, i) => {
    const val = $acc(d, i);
    if (Array.isArray(val)) {
      return val.map((v) => $scale(v));
    }
    return $scale(val);
  };
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/helpers/getRange.js
function getRange([$scale]) {
  if (typeof $scale === "function") {
    if (typeof $scale.range === "function") {
      return $scale.range();
    }
    console.error("[LayerCake] Your scale doesn't have a `.range` method?");
  }
  return null;
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/helpers/printDebug.js
var indent = "    ";
function getRgb(clr) {
  const { r, g, b, opacity: o } = rgb(clr);
  if (![r, g, b].every((c) => c >= 0 && c <= 255)) {
    return false;
  }
  return { r, g, b, o };
}
function contrast({ r, g, b }) {
  const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
  return luminance > 0.6 ? "black" : "white";
}
function printDebug(obj) {
  console.log("/********* LayerCake Debug ************/");
  console.log("Bounding box:");
  printObject(obj.boundingBox);
  console.log("Data:");
  console.log(indent, obj.data);
  if (obj.flatData) {
    console.log("flatData:");
    console.log(indent, obj.flatData);
  }
  console.log("Scales:");
  Object.keys(obj.activeGetters).forEach((g) => {
    printScale(g, obj[`${g}Scale`], obj[g]);
  });
  console.log("/************ End LayerCake Debug ***************/\n");
}
function printObject(obj) {
  Object.entries(obj).forEach(([key, value]) => {
    console.log(`${indent}${key}:`, value);
  });
}
function printScale(s, scale, acc) {
  const scaleName = findScaleName(scale);
  console.log(`${indent}${s}:`);
  console.log(`${indent}${indent}Accessor: "${acc.toString()}"`);
  console.log(`${indent}${indent}Type: ${scaleName}`);
  printValues(scale, "domain");
  printValues(scale, "range", " ");
}
function printValues(scale, method, extraSpace = "") {
  const values = scale[method]();
  const colorValues = colorizeArray(values);
  if (colorValues) {
    printColorArray(colorValues, method, values);
  } else {
    console.log(`${indent}${indent}${toTitleCase(method)}:${extraSpace}`, values);
  }
}
function printColorArray(colorValues, method, values) {
  console.log(
    `${indent}${indent}${toTitleCase(method)}:    %cArray%c(${values.length}) ` + colorValues[0] + "%c ]",
    "color: #1377e4",
    "color: #737373",
    "color: #1478e4",
    ...colorValues[1],
    "color: #1478e4"
  );
}
function colorizeArray(arr) {
  const colors = [];
  const a = arr.map((d, i) => {
    const rgbo = getRgb(d);
    if (rgbo !== false) {
      colors.push(rgbo);
      const space2 = i === arr.length - 1 ? " " : "";
      return `%c ${d}${space2}`;
    }
    return d;
  });
  if (colors.length) {
    return [
      `%c[ ${a.join(", ")}`,
      colors.map(
        (d) => `background-color: rgba(${d.r}, ${d.g}, ${d.b}, ${d.o}); color:${contrast(d)};`
      )
    ];
  }
  return null;
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/LayerCake.svelte
var { Object: Object_1, console: console_1 } = globals;
var file = "node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/LayerCake.svelte";
function add_css(target) {
  append_styles(target, "svelte-vhzpsp", ".layercake-container.svelte-vhzpsp,.layercake-container.svelte-vhzpsp *{box-sizing:border-box}.layercake-container.svelte-vhzpsp{width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGF5ZXJDYWtlLnN2ZWx0ZSIsInNvdXJjZXMiOlsiTGF5ZXJDYWtlLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tXG5cdEBjb21wb25lbnRcblx0TGF5ZXIgQ2FrZSBjb21wb25lbnRcbiAtLT5cbjxzY3JpcHQ+XG5cdGltcG9ydCB7IHNldENvbnRleHQsIG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyB3cml0YWJsZSwgZGVyaXZlZCB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XG5cblx0aW1wb3J0IG1ha2VBY2Nlc3NvciBmcm9tICcuL3V0aWxzL21ha2VBY2Nlc3Nvci5qcyc7XG5cdGltcG9ydCBmaWx0ZXJPYmplY3QgZnJvbSAnLi91dGlscy9maWx0ZXJPYmplY3QuanMnO1xuXHRpbXBvcnQgZGVib3VuY2UgZnJvbSAnLi91dGlscy9kZWJvdW5jZS5qcyc7XG5cblx0aW1wb3J0IGNhbGNTY2FsZUV4dGVudHMgZnJvbSAnLi9oZWxwZXJzL2NhbGNTY2FsZUV4dGVudHMuanMnO1xuXHRpbXBvcnQgY2FsY0RvbWFpbiBmcm9tICcuL2hlbHBlcnMvY2FsY0RvbWFpbi5qcyc7XG5cdGltcG9ydCBjcmVhdGVTY2FsZSBmcm9tICcuL2hlbHBlcnMvY3JlYXRlU2NhbGUuanMnO1xuXHRpbXBvcnQgY3JlYXRlR2V0dGVyIGZyb20gJy4vaGVscGVycy9jcmVhdGVHZXR0ZXIuanMnO1xuXHRpbXBvcnQgZ2V0UmFuZ2UgZnJvbSAnLi9oZWxwZXJzL2dldFJhbmdlLmpzJztcblx0aW1wb3J0IHByaW50RGVidWcgZnJvbSAnLi9oZWxwZXJzL3ByaW50RGVidWcuanMnO1xuXG5cdGltcG9ydCBkZWZhdWx0U2NhbGVzIGZyb20gJy4vc2V0dGluZ3MvZGVmYXVsdFNjYWxlcy5qcyc7XG5cblx0Y29uc3QgcHJpbnREZWJ1Z19kZWJvdW5jZWQgPSBkZWJvdW5jZShwcmludERlYnVnLCAyMDApO1xuXG5cdC8qKiBAdHlwZSB7Ym9vbGVhbn0gW3Nzcj1mYWxzZV0gV2hldGhlciB0aGlzIGNoYXJ0IHNob3VsZCBiZSByZW5kZXJlZCBzZXJ2ZXIgc2lkZS4gKi9cblx0ZXhwb3J0IGxldCBzc3IgPSBmYWxzZTtcblx0LyoqIEB0eXBlIHtib29sZWFufSBbcG9pbnRlckV2ZW50cz10cnVlXSBXaGV0aGVyIHRvIGFsbG93IHBvaW50ZXIgZXZlbnRzIHZpYSBDU1MuIFNldCB0aGlzIHRvIGBmYWxzZWAgdG8gc2V0IGBwb2ludGVyLWV2ZW50czogbm9uZTtgIG9uIGFsbCBjb21wb25lbnRzLCBkaXNhYmxpbmcgYWxsIG1vdXNlIGludGVyYWN0aW9uLiAqL1xuXHRleHBvcnQgbGV0IHBvaW50ZXJFdmVudHMgPSB0cnVlO1xuXHQvKiogQHR5cGUge1N0cmluZ30gW3Bvc2l0aW9uPSdyZWxhdGl2ZSddIERldGVybWluZSB0aGUgcG9zaXRpb25pbmcgb2YgdGhlIHdyYXBwZXIgZGl2LiBTZXQgdGhpcyB0byBgJ2Fic29sdXRlJ2Agd2hlbiB5b3Ugd2FudCB0byBzdGFjayBjYWtlcy4gKi9cblx0ZXhwb3J0IGxldCBwb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cdC8qKiBAdHlwZSB7Ym9vbGVhbn0gW3BlcmNlbnRSYW5nZT1mYWxzZV0gSWYgYHRydWVgLCBzZXQgYWxsIHNjYWxlIHJhbmdlcyB0byBgWzAsIDEwMF1gLiBSYW5nZXMgcmV2ZXJzZWQgdmlhIGB4UmV2ZXJzZWAsIGB5UmV2ZXJzZWAsIGB6UmV2ZXJzZWAgb3IgYHJSZXZlcnNlYCBwcm9wcyB3aWxsIGNvbnRpbnVlIHRvIGJlIHJldmVyc2VkIGFzIHVzdWFsLiAqL1xuXHRleHBvcnQgbGV0IHBlcmNlbnRSYW5nZSA9IGZhbHNlO1xuXG5cdC8qKiBAdHlwZSB7TnVtYmVyfSBbd2lkdGg9Y29udGFpbmVyV2lkdGhdIE92ZXJyaWRlIHRoZSBhdXRvbWF0ZWQgd2lkdGguICovXG5cdGV4cG9ydCBsZXQgd2lkdGggPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7TnVtYmVyfSBbaGVpZ2h0PWNvbnRhaW5lckhlaWdodF0gT3ZlcnJpZGUgdGhlIGF1dG9tYXRlZCBoZWlnaHQuICovXG5cdGV4cG9ydCBsZXQgaGVpZ2h0ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7TnVtYmVyfSBbY29udGFpbmVyV2lkdGg9MTAwXSBUaGUgYm91bmQgY29udGFpbmVyIHdpZHRoLiAqL1xuXHRleHBvcnQgbGV0IGNvbnRhaW5lcldpZHRoID0gd2lkdGggfHwgMTAwO1xuXHQvKiogQHR5cGUge051bWJlcn0gW2NvbnRhaW5lckhlaWdodD0xMDBdIFRoZSBib3VuZCBjb250YWluZXIgaGVpZ2h0LiAqL1xuXHRleHBvcnQgbGV0IGNvbnRhaW5lckhlaWdodCA9IGhlaWdodCB8fCAxMDA7XG5cblx0LyoqXHRAdHlwZSB7RWxlbWVudHx1bmRlZmluZWR9IFtlbGVtZW50XSBUaGUgLmxheWVyY2FrZS1jb250YWluZXIgYDxkaXY+YCB0YWcuIFVzZWZ1bCBmb3IgYmluZGluZ3MuICovXG5cdGV4cG9ydCBsZXQgZWxlbWVudCA9IHVuZGVmaW5lZDtcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKiBQYXJhbWV0ZXJzXG5cdCAqIFZhbHVlcyB0aGF0IGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGJhc2VkIG9uIGFuZCB0aGF0XG5cdCAqIGNhbiBiZSBlYXNpbHkgZXh0ZW5kZWQgZnJvbSBjb25maWcgdmFsdWVzXG5cdCAqXG5cdCAqL1xuXG5cdC8qKiBAdHlwZSB7U3RyaW5nfEZ1bmN0aW9ufE51bWJlcnxBcnJheTxTdHJpbmd8RnVuY3Rpb258TnVtYmVyPnx1bmRlZmluZWR9IHggVGhlIHggYWNjZXNzb3IuIFRoZSBrZXkgaW4gZWFjaCByb3cgb2YgZGF0YSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSB4LWZpZWxkLiBUaGlzIGNhbiBiZSBhIHN0cmluZywgYW4gYWNjZXNzb3IgZnVuY3Rpb24sIGEgbnVtYmVyIG9yIGFuIGFycmF5IG9mIGFueSBjb21iaW5hdGlvbiBvZiB0aG9zZSB0eXBlcy4gVGhpcyBwcm9wZXJ0eSBnZXRzIGNvbnZlcnRlZCB0byBhIGZ1bmN0aW9uIHdoZW4geW91IGFjY2VzcyBpdCB0aHJvdWdoIHRoZSBjb250ZXh0LiAqL1xuXHRleHBvcnQgbGV0IHggPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7U3RyaW5nfEZ1bmN0aW9ufE51bWJlcnxBcnJheTxTdHJpbmd8RnVuY3Rpb258TnVtYmVyPnx1bmRlZmluZWR9IHkgVGhlIHkgYWNjZXNzb3IuIFRoZSBrZXkgaW4gZWFjaCByb3cgb2YgZGF0YSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSB5LWZpZWxkLiBUaGlzIGNhbiBiZSBhIHN0cmluZywgYW4gYWNjZXNzb3IgZnVuY3Rpb24sIGEgbnVtYmVyIG9yIGFuIGFycmF5IG9mIGFueSBjb21iaW5hdGlvbiBvZiB0aG9zZSB0eXBlcy4gVGhpcyBwcm9wZXJ0eSBnZXRzIGNvbnZlcnRlZCB0byBhIGZ1bmN0aW9uIHdoZW4geW91IGFjY2VzcyBpdCB0aHJvdWdoIHRoZSBjb250ZXh0LiAqL1xuXHRleHBvcnQgbGV0IHkgPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7U3RyaW5nfEZ1bmN0aW9ufE51bWJlcnxBcnJheTxTdHJpbmd8RnVuY3Rpb258TnVtYmVyPnx1bmRlZmluZWR9IHogVGhlIHogYWNjZXNzb3IuIFRoZSBrZXkgaW4gZWFjaCByb3cgb2YgZGF0YSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSB6LWZpZWxkLiBUaGlzIGNhbiBiZSBhIHN0cmluZywgYW4gYWNjZXNzb3IgZnVuY3Rpb24sIGEgbnVtYmVyIG9yIGFuIGFycmF5IG9mIGFueSBjb21iaW5hdGlvbiBvZiB0aG9zZSB0eXBlcy4gVGhpcyBwcm9wZXJ0eSBnZXRzIGNvbnZlcnRlZCB0byBhIGZ1bmN0aW9uIHdoZW4geW91IGFjY2VzcyBpdCB0aHJvdWdoIHRoZSBjb250ZXh0LiAqL1xuXHRleHBvcnQgbGV0IHogPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7U3RyaW5nfEZ1bmN0aW9ufE51bWJlcnxBcnJheTxTdHJpbmd8RnVuY3Rpb258TnVtYmVyPnx1bmRlZmluZWR9IHIgVGhlIHIgYWNjZXNzb3IuIFRoZSBrZXkgaW4gZWFjaCByb3cgb2YgZGF0YSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSByLWZpZWxkLiBUaGlzIGNhbiBiZSBhIHN0cmluZywgYW4gYWNjZXNzb3IgZnVuY3Rpb24sIGEgbnVtYmVyIG9yIGFuIGFycmF5IG9mIGFueSBjb21iaW5hdGlvbiBvZiB0aG9zZSB0eXBlcy4gVGhpcyBwcm9wZXJ0eSBnZXRzIGNvbnZlcnRlZCB0byBhIGZ1bmN0aW9uIHdoZW4geW91IGFjY2VzcyBpdCB0aHJvdWdoIHRoZSBjb250ZXh0LiAqL1xuXHRleHBvcnQgbGV0IHIgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtBcnJheTxPYmplY3Q+fE9iamVjdH0gW2RhdGE9W11dIElmIGBkYXRhYCBpcyBub3QgYSBmbGF0IGFycmF5IG9mIG9iamVjdHMgYW5kIHlvdSB3YW50IHRvIHVzZSBhbnkgb2YgdGhlIHNjYWxlcywgc2V0IGEgZmxhdCB2ZXJzaW9uIG9mIHRoZSBkYXRhIHZpYSB0aGUgYGZsYXREYXRhYCBwcm9wLiAqL1xuXHRleHBvcnQgbGV0IGRhdGEgPSBbXTtcblxuXHQvKiogQHR5cGUge1ttaW46IE51bWJlcnxudWxsLCBtYXg6IE51bWJlcnxudWxsXXxBcnJheTxTdHJpbmd8TnVtYmVyPnxGdW5jdGlvbnx1bmRlZmluZWR9IFt4RG9tYWluXSBTZXQgYSBtaW4gb3IgbWF4LiBGb3IgbGluZWFyIHNjYWxlcywgaWYgeW91IHdhbnQgdG8gaW5oZXJpdCB0aGUgdmFsdWUgZnJvbSB0aGUgZGF0YSdzIGV4dGVudCwgc2V0IHRoYXQgdmFsdWUgdG8gYG51bGxgLiBUaGlzIHZhbHVlIGNhbiBhbHNvIGJlIGFuIGFycmF5IGJlY2F1c2Ugc29tZXRpbWVzIHlvdXIgc2NhbGVzIGFyZSBbcGllY2V3aXNlXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjY29udGludW91c19kb21haW4pIG9yIGFyZSBhIGxpc3Qgb2YgZGlzY3JldGUgdmFsdWVzIHN1Y2ggYXMgaW4gW29yZGluYWwgc2NhbGVzXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjb3JkaW5hbC1zY2FsZXMpLCB1c2VmdWwgZm9yIGNvbG9yIHNlcmllcy4gU2V0IGl0IHRvIGEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgY29tcHV0ZWQgZG9tYWluIGFuZCBsZXRzIHlvdSByZXR1cm4gYSBtb2RpZmllZCBkb21haW4sIHVzZWZ1bCBmb3Igc29ydGluZyB2YWx1ZXMuICovXG5cdGV4cG9ydCBsZXQgeERvbWFpbiA9IHVuZGVmaW5lZDtcblx0LyoqIEB0eXBlIHtbbWluOiBOdW1iZXJ8bnVsbCwgbWF4OiBOdW1iZXJ8bnVsbF18QXJyYXk8U3RyaW5nfE51bWJlcj58RnVuY3Rpb258dW5kZWZpbmVkfSBbeURvbWFpbl0gU2V0IGEgbWluIG9yIG1heC4gRm9yIGxpbmVhciBzY2FsZXMsIGlmIHlvdSB3YW50IHRvIGluaGVyaXQgdGhlIHZhbHVlIGZyb20gdGhlIGRhdGEncyBleHRlbnQsIHNldCB0aGF0IHZhbHVlIHRvIGBudWxsYC4gIFNldCBpdCB0byBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGNvbXB1dGVkIGRvbWFpbiBhbmQgbGV0cyB5b3UgcmV0dXJuIGEgbW9kaWZpZWQgZG9tYWluLCB1c2VmdWwgZm9yIHNvcnRpbmcgdmFsdWVzLiAqL1xuXHRleHBvcnQgbGV0IHlEb21haW4gPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7W21pbjogTnVtYmVyfG51bGwsIG1heDogTnVtYmVyfG51bGxdfEFycmF5PFN0cmluZ3xOdW1iZXI+fEZ1bmN0aW9ufHVuZGVmaW5lZH0gW3pEb21haW5dIFNldCBhIG1pbiBvciBtYXguIEZvciBsaW5lYXIgc2NhbGVzLCBpZiB5b3Ugd2FudCB0byBpbmhlcml0IHRoZSB2YWx1ZSBmcm9tIHRoZSBkYXRhJ3MgZXh0ZW50LCBzZXQgdGhhdCB2YWx1ZSB0byBgbnVsbGAuIFRoaXMgdmFsdWUgY2FuIGFsc28gYmUgYW4gYXJyYXkgYmVjYXVzZSBzb21ldGltZXMgeW91ciBzY2FsZXMgYXJlIFtwaWVjZXdpc2VdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSNjb250aW51b3VzX2RvbWFpbikgb3IgYXJlIGEgbGlzdCBvZiBkaXNjcmV0ZSB2YWx1ZXMgc3VjaCBhcyBpbiBbb3JkaW5hbCBzY2FsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSNvcmRpbmFsLXNjYWxlcyksIHVzZWZ1bCBmb3IgY29sb3Igc2VyaWVzLiBTZXQgaXQgdG8gYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBjb21wdXRlZCBkb21haW4gYW5kIGxldHMgeW91IHJldHVybiBhIG1vZGlmaWVkIGRvbWFpbiwgdXNlZnVsIGZvciBzb3J0aW5nIHZhbHVlcy4gKi9cblx0ZXhwb3J0IGxldCB6RG9tYWluID0gdW5kZWZpbmVkO1xuXHQvKiogQHR5cGUge1ttaW46IE51bWJlcnxudWxsLCBtYXg6IE51bWJlcnxudWxsXXxBcnJheTxTdHJpbmd8TnVtYmVyPnxGdW5jdGlvbnx1bmRlZmluZWR9IFtyRG9tYWluXSBTZXQgYSBtaW4gb3IgbWF4LiBGb3IgbGluZWFyIHNjYWxlcywgaWYgeW91IHdhbnQgdG8gaW5oZXJpdCB0aGUgdmFsdWUgZnJvbSB0aGUgZGF0YSdzIGV4dGVudCwgc2V0IHRoYXQgdmFsdWUgdG8gYG51bGxgLiBUaGlzIHZhbHVlIGNhbiBhbHNvIGJlIGFuIGFycmF5IGJlY2F1c2Ugc29tZXRpbWVzIHlvdXIgc2NhbGVzIGFyZSBbcGllY2V3aXNlXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjY29udGludW91c19kb21haW4pIG9yIGFyZSBhIGxpc3Qgb2YgZGlzY3JldGUgdmFsdWVzIHN1Y2ggYXMgaW4gW29yZGluYWwgc2NhbGVzXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjb3JkaW5hbC1zY2FsZXMpLCB1c2VmdWwgZm9yIGNvbG9yIHNlcmllcy4gU2V0IGl0IHRvIGEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgY29tcHV0ZWQgZG9tYWluIGFuZCBsZXRzIHlvdSByZXR1cm4gYSBtb2RpZmllZCBkb21haW4sIHVzZWZ1bCBmb3Igc29ydGluZyB2YWx1ZXMuICovXG5cdGV4cG9ydCBsZXQgckRvbWFpbiA9IHVuZGVmaW5lZDtcblx0LyoqIEB0eXBlIHtib29sZWFufE51bWJlcn0gW3hOaWNlPWZhbHNlXSBBcHBsaWVzIEQzJ3MgW3NjYWxlLm5pY2UoKV0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI2NvbnRpbnVvdXNfbmljZSkgdG8gdGhlIHggZG9tYWluLiAqL1xuXHRleHBvcnQgbGV0IHhOaWNlID0gZmFsc2U7XG5cdC8qKiBAdHlwZSB7Ym9vbGVhbnxOdW1iZXJ9IFt5TmljZT1mYWxzZV0gQXBwbGllcyBEMydzIFtzY2FsZS5uaWNlKCldKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSNjb250aW51b3VzX25pY2UpIHRvIHRoZSB5IGRvbWFpbi4gKi9cblx0ZXhwb3J0IGxldCB5TmljZSA9IGZhbHNlO1xuXHQvKiogQHR5cGUge2Jvb2xlYW58TnVtYmVyfSBbek5pY2U9ZmFsc2VdIEFwcGxpZXMgRDMncyBbc2NhbGUubmljZSgpXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjY29udGludW91c19uaWNlKSB0byB0aGUgeiBkb21haW4uICovXG5cdGV4cG9ydCBsZXQgek5pY2UgPSBmYWxzZTtcblx0LyoqIEB0eXBlIHtib29sZWFufSBbck5pY2U9ZmFsc2VdIEFwcGxpZXMgRDMncyBbc2NhbGUubmljZSgpXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjY29udGludW91c19uaWNlKSB0byB0aGUgciBkb21haW4uICovXG5cdGV4cG9ydCBsZXQgck5pY2UgPSBmYWxzZTtcblx0LyoqIEB0eXBlIHtbbGVmdFBpeGVsczogTnVtYmVyLCByaWdodFBpeGVsczogTnVtYmVyXXx1bmRlZmluZWR9IFt4UGFkZGluZ10gQXNzaWduIGEgcGl4ZWwgdmFsdWUgdG8gYWRkIHRvIHRoZSBtaW4gb3IgbWF4IG9mIHRoZSBzY2FsZS4gVGhpcyB3aWxsIGluY3JlYXNlIHRoZSBzY2FsZXMgZG9tYWluIGJ5IHRoZSBzY2FsZSB1bml0IGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIHBpeGVscy4gKi9cblx0ZXhwb3J0IGxldCB4UGFkZGluZyA9IHVuZGVmaW5lZDtcblx0LyoqIEB0eXBlIHtbbGVmdFBpeGVsczogTnVtYmVyLCByaWdodFBpeGVsczogTnVtYmVyXXx1bmRlZmluZWR9IFt5UGFkZGluZ10gQXNzaWduIGEgcGl4ZWwgdmFsdWUgdG8gYWRkIHRvIHRoZSBtaW4gb3IgbWF4IG9mIHRoZSBzY2FsZS4gVGhpcyB3aWxsIGluY3JlYXNlIHRoZSBzY2FsZXMgZG9tYWluIGJ5IHRoZSBzY2FsZSB1bml0IGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIHBpeGVscy4gKi9cblx0ZXhwb3J0IGxldCB5UGFkZGluZyA9IHVuZGVmaW5lZDtcblx0LyoqIEB0eXBlIHtbbGVmdFBpeGVsczogTnVtYmVyLCByaWdodFBpeGVsczogTnVtYmVyXXx1bmRlZmluZWR9IFt6UGFkZGluZ10gQXNzaWduIGEgcGl4ZWwgdmFsdWUgdG8gYWRkIHRvIHRoZSBtaW4gb3IgbWF4IG9mIHRoZSBzY2FsZS4gVGhpcyB3aWxsIGluY3JlYXNlIHRoZSBzY2FsZXMgZG9tYWluIGJ5IHRoZSBzY2FsZSB1bml0IGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIHBpeGVscy4gKi9cblx0ZXhwb3J0IGxldCB6UGFkZGluZyA9IHVuZGVmaW5lZDtcblx0LyoqIEB0eXBlIHtbbGVmdFBpeGVsczogTnVtYmVyLCByaWdodFBpeGVsczogTnVtYmVyXXx1bmRlZmluZWR9IFtyUGFkZGluZ10gQXNzaWduIGEgcGl4ZWwgdmFsdWUgdG8gYWRkIHRvIHRoZSBtaW4gb3IgbWF4IG9mIHRoZSBzY2FsZS4gVGhpcyB3aWxsIGluY3JlYXNlIHRoZSBzY2FsZXMgZG9tYWluIGJ5IHRoZSBzY2FsZSB1bml0IGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIHBpeGVscy4gKi9cblx0ZXhwb3J0IGxldCByUGFkZGluZyA9IHVuZGVmaW5lZDtcblx0LyoqIEB0eXBlIHtGdW5jdGlvbn0gW3hTY2FsZT1kMy5zY2FsZUxpbmVhcl0gVGhlIEQzIHNjYWxlIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIHRoZSB4LWRpbWVuc2lvbi4gUGFzcyBpbiBhbiBpbnN0YW50aWF0ZWQgRDMgc2NhbGUgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb3IgeW91IHdhbnQgdG8gZXh0cmEgb3B0aW9ucy4gKi9cblx0ZXhwb3J0IGxldCB4U2NhbGUgPSBkZWZhdWx0U2NhbGVzLng7XG5cdC8qKiBAdHlwZSB7RnVuY3Rpb259IFt5U2NhbGU9ZDMuc2NhbGVMaW5lYXJdIFRoZSBEMyBzY2FsZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciB0aGUgeC1kaW1lbnNpb24uIFBhc3MgaW4gYW4gaW5zdGFudGlhdGVkIEQzIHNjYWxlIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9yIHlvdSB3YW50IHRvIGV4dHJhIG9wdGlvbnMuICovXG5cdGV4cG9ydCBsZXQgeVNjYWxlID0gZGVmYXVsdFNjYWxlcy55O1xuXHQvKiogQHR5cGUge0Z1bmN0aW9ufSBbelNjYWxlPWQzLnNjYWxlTGluZWFyXSBUaGUgRDMgc2NhbGUgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIHgtZGltZW5zaW9uLiBQYXNzIGluIGFuIGluc3RhbnRpYXRlZCBEMyBzY2FsZSBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBvciB5b3Ugd2FudCB0byBleHRyYSBvcHRpb25zLiAqL1xuXHRleHBvcnQgbGV0IHpTY2FsZSA9IGRlZmF1bHRTY2FsZXMuejtcblx0LyoqIEB0eXBlIHtGdW5jdGlvbn0gW3JTY2FsZT1kMy5zY2FsZVNxcnRdIFRoZSBEMyBzY2FsZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciB0aGUgeC1kaW1lbnNpb24uIFBhc3MgaW4gYW4gaW5zdGFudGlhdGVkIEQzIHNjYWxlIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9yIHlvdSB3YW50IHRvIGV4dHJhIG9wdGlvbnMuICovXG5cdGV4cG9ydCBsZXQgclNjYWxlID0gZGVmYXVsdFNjYWxlcy5yO1xuXHQvKiogQHR5cGUge1ttaW46IE51bWJlciwgbWF4OiBOdW1iZXJdfEZ1bmN0aW9ufEFycmF5PFN0cmluZ3xOdW1iZXI+fHVuZGVmaW5lZH0gW3hSYW5nZV0gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgeCByYW5nZSBvZiBgWzAsIHdpZHRoXWAgYnkgc2V0dGluZyBhbiBhcnJheSBvciBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50IGAoeyB3aWR0aCwgaGVpZ2h0fSlgIHRoYXQgcmV0dXJucyBhbiBhcnJheS4gU2V0dGluZyB0aGlzIHByb3Agb3ZlcnJpZGVzIGB4UmV2ZXJzZWAuIFRoaXMgY2FuIGFsc28gYmUgYSBsaXN0IG9mIG51bWJlcnMgb3Igc3RyaW5ncyBmb3Igc2NhbGVzIHdpdGggZGlzY3JldGUgcmFuZ2VzIGxpa2UgW3NjYWxlVGhyZXNoaG9sZF0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3RocmVzaG9sZC1zY2FsZXMpIG9yIFtzY2FsZVF1YW50aXplXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjcXVhbnRpemUtc2NhbGVzKS4gKi9cblx0ZXhwb3J0IGxldCB4UmFuZ2UgPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7W21pbjogTnVtYmVyLCBtYXg6IE51bWJlcl18RnVuY3Rpb258QXJyYXk8U3RyaW5nfE51bWJlcj58dW5kZWZpbmVkfSBbeFJhbmdlXSBPdmVycmlkZSB0aGUgZGVmYXVsdCB5IHJhbmdlIG9mIGBbMCwgaGVpZ2h0XWAgYnkgc2V0dGluZyBhbiBhcnJheSBvciBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50IGAoeyB3aWR0aCwgaGVpZ2h0fSlgIHRoYXQgcmV0dXJucyBhbiBhcnJheS4gU2V0dGluZyB0aGlzIHByb3Agb3ZlcnJpZGVzIGB5UmV2ZXJzZWAuIFRoaXMgY2FuIGFsc28gYmUgYSBsaXN0IG9mIG51bWJlcnMgb3Igc3RyaW5ncyBmb3Igc2NhbGVzIHdpdGggZGlzY3JldGUgcmFuZ2VzIGxpa2UgW3NjYWxlVGhyZXNoaG9sZF0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3RocmVzaG9sZC1zY2FsZXMpIG9yIFtzY2FsZVF1YW50aXplXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjcXVhbnRpemUtc2NhbGVzKS4gKi9cblx0ZXhwb3J0IGxldCB5UmFuZ2UgPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7W21pbjogTnVtYmVyLCBtYXg6IE51bWJlcl18RnVuY3Rpb258QXJyYXk8U3RyaW5nfE51bWJlcj58dW5kZWZpbmVkfSBbelJhbmdlXSBPdmVycmlkZSB0aGUgZGVmYXVsdCB6IHJhbmdlIG9mIGBbMCwgd2lkdGhdYCBieSBzZXR0aW5nIGFuIGFycmF5IG9yIGZ1bmN0aW9uIHdpdGggYXJndW1lbnQgYCh7IHdpZHRoLCBoZWlnaHR9KWAgdGhhdCByZXR1cm5zIGFuIGFycmF5LiBTZXR0aW5nIHRoaXMgcHJvcCBvdmVycmlkZXMgYHpSZXZlcnNlYC4gVGhpcyBjYW4gYWxzbyBiZSBhIGxpc3Qgb2YgbnVtYmVycyBvciBzdHJpbmdzIGZvciBzY2FsZXMgd2l0aCBkaXNjcmV0ZSByYW5nZXMgbGlrZSBbc2NhbGVUaHJlc2hob2xkXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjdGhyZXNob2xkLXNjYWxlcykgb3IgW3NjYWxlUXVhbnRpemVdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSNxdWFudGl6ZS1zY2FsZXMpLiAqL1xuXHRleHBvcnQgbGV0IHpSYW5nZSA9IHVuZGVmaW5lZDtcblx0LyoqIEB0eXBlIHtbbWluOiBOdW1iZXIsIG1heDogTnVtYmVyXXxGdW5jdGlvbnxBcnJheTxTdHJpbmd8TnVtYmVyPnx1bmRlZmluZWR9IFtyUmFuZ2VdIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHIgcmFuZ2Ugb2YgYFsxLCAyNV1gIGJ5IHNldHRpbmcgYW4gYXJyYXkgb3IgZnVuY3Rpb24gd2l0aCBhcmd1bWVudCBgKHsgd2lkdGgsIGhlaWdodH0pYCB0aGF0IHJldHVybnMgYW4gYXJyYXkuIFNldHRpbmcgdGhpcyBwcm9wIG92ZXJyaWRlcyBgclJldmVyc2VgLiBUaGlzIGNhbiBhbHNvIGJlIGEgbGlzdCBvZiBudW1iZXJzIG9yIHN0cmluZ3MgZm9yIHNjYWxlcyB3aXRoIGRpc2NyZXRlIHJhbmdlcyBsaWtlIFtzY2FsZVRocmVzaGhvbGRdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSN0aHJlc2hvbGQtc2NhbGVzKSBvciBbc2NhbGVRdWFudGl6ZV0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3F1YW50aXplLXNjYWxlcykuICovXG5cdGV4cG9ydCBsZXQgclJhbmdlID0gdW5kZWZpbmVkO1xuXHQvKiogQHR5cGUge2Jvb2xlYW59IFt4UmV2ZXJzZT1mYWxzZV0gUmV2ZXJzZSB0aGUgZGVmYXVsdCB4IHJhbmdlLiBCeSBkZWZhdWx0IHRoaXMgaXMgYGZhbHNlYCBhbmQgdGhlIHJhbmdlIGlzIGBbMCwgd2lkdGhdYC4gSWdub3JlZCBpZiB5b3Ugc2V0IHRoZSB4UmFuZ2UgcHJvcC4gKi9cblx0ZXhwb3J0IGxldCB4UmV2ZXJzZSA9IGZhbHNlO1xuXHQvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSBbeVJldmVyc2U9dHJ1ZV0gUmV2ZXJzZSB0aGUgZGVmYXVsdCB5IHJhbmdlLiBCeSBkZWZhdWx0IHRoaXMgaXMgc2V0IGR5bmFtaWNhbGx5IGFuZCB3aWxsIGJlIGB0cnVlYCDigJMgc2V0dGluZyB0aGUgcmFuZ2UgdG8gYFtoZWlnaHQsIDBdYCDigJMgdW5sZXNzIHRoZSBgeVNjYWxlYCBoYXMgYSBgLmJhbmR3aWR0aGAgbWV0aG9kLiBEeW5hbWljIGJlaGF2aW9yIGlzIG92ZXJyaWRkZW4gaWYgdGhlIHVzZXIgc2V0cyB0aGUgcHJvcC4gSWdub3JlZCBpZiB5b3Ugc2V0IHRoZSBgeVJhbmdlYCBwcm9wLiAqL1xuXHRleHBvcnQgbGV0IHlSZXZlcnNlID0gdW5kZWZpbmVkO1xuXHQvKiogQHR5cGUge2Jvb2xlYW59IFt6UmV2ZXJzZT1mYWxzZV0gUmV2ZXJzZSB0aGUgZGVmYXVsdCB6IHJhbmdlLiBCeSBkZWZhdWx0IHRoaXMgaXMgYGZhbHNlYCBhbmQgdGhlIHJhbmdlIGlzIGBbMCwgd2lkdGhdYC4gSWdub3JlZCBpZiB5b3Ugc2V0IHRoZSB6UmFuZ2UgcHJvcC4gKi9cblx0ZXhwb3J0IGxldCB6UmV2ZXJzZSA9IGZhbHNlO1xuXHQvKiogQHR5cGUge2Jvb2xlYW59IFtyUmV2ZXJzZT1mYWxzZV0gUmV2ZXJzZSB0aGUgZGVmYXVsdCByIHJhbmdlLiBCeSBkZWZhdWx0IHRoaXMgaXMgYGZhbHNlYCBhbmQgdGhlIHJhbmdlIGlzIGBbMSwgMjVdYC4gSWdub3JlZCBpZiB5b3Ugc2V0IHRoZSByUmFuZ2UgcHJvcC4gKi9cblx0ZXhwb3J0IGxldCByUmV2ZXJzZSA9IGZhbHNlO1xuXHQvKiogQHR5cGUge2Jvb2xlYW59IFt4RG9tYWluU29ydD10cnVlXSBPbmx5IHVzZWQgd2hlbiBzY2FsZSBpcyBvcmRpbmFsLiBTZXQgd2hldGhlciB0aGUgY2FsY3VsYXRlZCB1bmlxdWUgaXRlbXMgY29tZSBiYWNrIHNvcnRlZC4gKi9cblx0ZXhwb3J0IGxldCB4RG9tYWluU29ydCA9IHRydWU7XG5cdC8qKiBAdHlwZSB7Ym9vbGVhbn0gW3lEb21haW5Tb3J0PXRydWVdIE9ubHkgdXNlZCB3aGVuIHNjYWxlIGlzIG9yZGluYWwuIFNldCB3aGV0aGVyIHRoZSBjYWxjdWxhdGVkIHVuaXF1ZSBpdGVtcyBjb21lIGJhY2sgc29ydGVkLiAqL1xuXHRleHBvcnQgbGV0IHlEb21haW5Tb3J0ID0gdHJ1ZTtcblx0LyoqIEB0eXBlIHtib29sZWFufSBbekRvbWFpblNvcnQ9dHJ1ZV0gT25seSB1c2VkIHdoZW4gc2NhbGUgaXMgb3JkaW5hbC4gU2V0IHdoZXRoZXIgdGhlIGNhbGN1bGF0ZWQgdW5pcXVlIGl0ZW1zIGNvbWUgYmFjayBzb3J0ZWQuICovXG5cdGV4cG9ydCBsZXQgekRvbWFpblNvcnQgPSB0cnVlO1xuXHQvKiogQHR5cGUge2Jvb2xlYW59IFtyRG9tYWluU29ydD10cnVlXSBPbmx5IHVzZWQgd2hlbiBzY2FsZSBpcyBvcmRpbmFsLiBTZXQgd2hldGhlciB0aGUgY2FsY3VsYXRlZCB1bmlxdWUgaXRlbXMgY29tZSBiYWNrIHNvcnRlZC4gKi9cblx0ZXhwb3J0IGxldCByRG9tYWluU29ydCA9IHRydWU7XG5cdC8qKiBAdHlwZSB7e3RvcD86IE51bWJlciwgcmlnaHQ/OiBOdW1iZXIsIGJvdHRvbT86IE51bWJlciwgbGVmdD86IE51bWJlcn19IFtwYWRkaW5nPXt9XSBUaGUgYW1vdW50IG9mIHBhZGRpbmcgdG8gcHV0IGFyb3VuZCB5b3VyIGNoYXJ0LiBJdCBvcGVyYXRlcyBsaWtlIENTUyBib3gtc2l6aW5nOiBib3JkZXItYm94OyB3aGVyZSB2YWx1ZXMgYXJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgcGFyZW50IGNvbnRhaW5lcidzIHdpZHRoIGFuZCBoZWlnaHQsIHRoZSBzYW1lIGFzIGEgW0QzIG1hcmdpbiBjb252ZW50aW9uXShodHRwczovL2JsLm9ja3Mub3JnL21ib3N0b2NrLzMwMTk1NjMpLiAqL1xuXHRleHBvcnQgbGV0IHBhZGRpbmcgPSB7fTtcblx0LyoqIEB0eXBlIHt7IHg/OiBbbWluOiBOdW1iZXIsIG1heDogTnVtYmVyXSwgeT86IFttaW46IE51bWJlciwgbWF4OiBOdW1iZXJdLCByPzogW21pbjogTnVtYmVyLCBtYXg6IE51bWJlcl0sIHo/OiBbbWluOiBOdW1iZXIsIG1heDogTnVtYmVyXSB9fSBbZXh0ZW50c10gTWFudWFsbHkgc2V0IHRoZSBleHRlbnRzIG9mIHRoZSB4LCB5IG9yIHIgc2NhbGUgYXMgYSB0d28tZGltZW5zaW9uYWwgYXJyYXkgb2YgdGhlIG1pbiBhbmQgbWF4IHlvdSB3YW50LiBTZXR0aW5nIHZhbHVlcyBoZXJlIHdpbGwgc2tpcCBhbnkgZHluYW1pYyBleHRlbnQgY2FsY3VsYXRpb24gb2YgdGhlIGRhdGEgZm9yIHRoYXQgZGltZW5zaW9uLiAqL1xuXHRleHBvcnQgbGV0IGV4dGVudHMgPSB7fTtcblx0LyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24oe3hTY2FsZSwgeVNjYWxlLCB6U2NhbGUsIHJTY2FsZX0pOiBEM1NjYWxlPn0gW2Rlcml2ZVNjYWxlc10gQ3JlYXRlIG5ldyBzY2FsZXMgYmFzZWQgb24gdmFsdWVzIG9mIG90aGVycy4gVGFrZXMgYW4gb2JqZWN0IHdoZXJlIGVhY2gga2V5IGlzIGFuIGFyYml0cmFyeSBuYW1lIGZvciB0aGUgZGVyaXZlZCBzY2FsZS4gVGhlIHZhbHVlIGlzIGEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhbiBvYmplY3Qgd2l0aCBhdmFpbGFibGUgc2NhbGVzIGFuZCByZXR1cm5zIHRoZSBuZXcgc2NhbGUuICovXG5cdGV4cG9ydCBsZXQgZGVyaXZlU2NhbGVzID0ge307XG5cdC8qKiBAdHlwZSB7QXJyYXk8T2JqZWN0fEFycmF5PGFueT4+fHVuZGVmaW5lZH0gW2ZsYXREYXRhPWRhdGFdIEEgZmxhdCB2ZXJzaW9uIG9mIGRhdGEuICovXG5cdGV4cG9ydCBsZXQgZmxhdERhdGEgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtPYmplY3R9IGN1c3RvbSBBbnkgZXh0cmEgY29uZmlndXJhdGlvbiB2YWx1ZXMgeW91IHdhbnQgYXZhaWxhYmxlIG9uIHRoZSBMYXllckNha2UgY29udGV4dC4gVGhpcyBjb3VsZCBiZSB1c2VmdWwgZm9yIGNvbG9yIGxvb2t1cHMgb3IgYWRkaXRpb25hbCBjb25zdGFudHMuICovXG5cdGV4cG9ydCBsZXQgY3VzdG9tID0ge307XG5cblx0LyoqIEB0eXBlIHtib29sZWFufSBkZWJ1ZyBFbmFibGUgZGVidWcgcHJpbnRpbmcgdG8gdGhlIGNvbnNvbGUuIFVzZWZ1bCB0byBpbnNwZWN0IHlvdXIgc2NhbGVzIGFuZCBkaW1lbnNpb25zLiAqL1xuXHRleHBvcnQgbGV0IGRlYnVnID0gZmFsc2U7XG5cdC8qKiBAdHlwZSB7Ym9vbGVhbn0gW3ZlcmJvc2U9dHJ1ZV0gU2hvdyB3YXJuaW5ncyBpbiB0aGUgY29uc29sZS4gKi9cblx0ZXhwb3J0IGxldCB2ZXJib3NlID0gdHJ1ZTtcblxuXHQvKipcblx0ICogTWFrZSB0aGlzIHJlYWN0aXZlXG5cdCAqL1xuXHQkOiB5UmV2ZXJzZVZhbHVlID1cblx0XHR0eXBlb2YgeVJldmVyc2UgPT09ICd1bmRlZmluZWQnXG5cdFx0XHQ/IHR5cGVvZiB5U2NhbGUuYmFuZHdpZHRoID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdD8gZmFsc2Vcblx0XHRcdFx0OiB0cnVlXG5cdFx0XHQ6IHlSZXZlcnNlO1xuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqIEtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkXG5cdCAqIFRoaXMgaXMgdXNlZCB0byBlbWl0IHdhcm5pbmdzIG9uY2Ugd2UgaGF2ZSBtZWFzdXJlZFxuXHQgKiB0aGUgY29udGFpbmVyIG9iamVjdCBhbmQgaXQgZG9lc24ndCBoYXZlIHByb3BlciBkaW1lbnNpb25zXG5cdCAqL1xuXHRsZXQgaXNNb3VudGVkID0gZmFsc2U7XG5cdG9uTW91bnQoKCkgPT4ge1xuXHRcdGlzTW91bnRlZCA9IHRydWU7XG5cdH0pO1xuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqIFByZXNlcnZlIGEgY29weSBvZiBvdXIgcGFzc2VkIGluIHNldHRpbmdzIGJlZm9yZSB3ZSBtb2RpZnkgdGhlbVxuXHQgKiBSZXR1cm4gdGhpcyB0byB0aGUgdXNlcidzIGNvbnRleHQgc28gdGhleSBjYW4gcmVmZXJlbmNlIHRoaW5ncyBpZiBuZWVkIGJlXG5cdCAqIEFkZCB0aGUgYWN0aXZlIGtleXMgc2luY2UgdGhvc2UgYXJlbid0IG9uIG91ciBzZXR0aW5ncyBvYmplY3QuXG5cdCAqIFRoaXMgaXMgbW9zdGx5IGFuIGVzY2FwZS1oYXRjaFxuXHQgKi9cblx0Y29uc3QgY29uZmlnID0ge307XG5cdCQ6IGlmICh4KSBjb25maWcueCA9IHg7XG5cdCQ6IGlmICh5KSBjb25maWcueSA9IHk7XG5cdCQ6IGlmICh6KSBjb25maWcueiA9IHo7XG5cdCQ6IGlmIChyKSBjb25maWcuciA9IHI7XG5cdCQ6IGlmICh4RG9tYWluKSBjb25maWcueERvbWFpbiA9IHhEb21haW47XG5cdCQ6IGlmICh5RG9tYWluKSBjb25maWcueURvbWFpbiA9IHlEb21haW47XG5cdCQ6IGlmICh6RG9tYWluKSBjb25maWcuekRvbWFpbiA9IHpEb21haW47XG5cdCQ6IGlmIChyRG9tYWluKSBjb25maWcuckRvbWFpbiA9IHJEb21haW47XG5cdCQ6IGlmICh4UmFuZ2UpIGNvbmZpZy54UmFuZ2UgPSB4UmFuZ2U7XG5cdCQ6IGlmICh5UmFuZ2UpIGNvbmZpZy55UmFuZ2UgPSB5UmFuZ2U7XG5cdCQ6IGlmICh6UmFuZ2UpIGNvbmZpZy56UmFuZ2UgPSB6UmFuZ2U7XG5cdCQ6IGlmIChyUmFuZ2UpIGNvbmZpZy5yUmFuZ2UgPSByUmFuZ2U7XG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICogTWFrZSBzdG9yZSB2ZXJzaW9ucyBvZiBlYWNoIHBhcmFtZXRlclxuXHQgKiBQcmVmaXggdGhlc2Ugd2l0aCBgX2AgdG8ga2VlcCB0aGluZ3Mgb3JnYW5pemVkXG5cdCAqL1xuXHRjb25zdCBfcGVyY2VudFJhbmdlID0gd3JpdGFibGUocGVyY2VudFJhbmdlKTtcblx0Y29uc3QgX2NvbnRhaW5lcldpZHRoID0gd3JpdGFibGUoY29udGFpbmVyV2lkdGgpO1xuXHRjb25zdCBfY29udGFpbmVySGVpZ2h0ID0gd3JpdGFibGUoY29udGFpbmVySGVpZ2h0KTtcblx0Y29uc3QgX2V4dGVudHMgPSB3cml0YWJsZShmaWx0ZXJPYmplY3QoZXh0ZW50cykpO1xuXHRjb25zdCBfZGF0YSA9IHdyaXRhYmxlKGRhdGEpO1xuXHRjb25zdCBfZmxhdERhdGEgPSB3cml0YWJsZShmbGF0RGF0YSB8fCBkYXRhKTtcblx0Y29uc3QgX3BhZGRpbmcgPSB3cml0YWJsZShwYWRkaW5nKTtcblx0Y29uc3QgX3ggPSB3cml0YWJsZShtYWtlQWNjZXNzb3IoeCkpO1xuXHRjb25zdCBfeSA9IHdyaXRhYmxlKG1ha2VBY2Nlc3Nvcih5KSk7XG5cdGNvbnN0IF96ID0gd3JpdGFibGUobWFrZUFjY2Vzc29yKHopKTtcblx0Y29uc3QgX3IgPSB3cml0YWJsZShtYWtlQWNjZXNzb3IocikpO1xuXHRjb25zdCBfeERvbWFpbiA9IHdyaXRhYmxlKHhEb21haW4pO1xuXHRjb25zdCBfeURvbWFpbiA9IHdyaXRhYmxlKHlEb21haW4pO1xuXHRjb25zdCBfekRvbWFpbiA9IHdyaXRhYmxlKHpEb21haW4pO1xuXHRjb25zdCBfckRvbWFpbiA9IHdyaXRhYmxlKHJEb21haW4pO1xuXHRjb25zdCBfeE5pY2UgPSB3cml0YWJsZSh4TmljZSk7XG5cdGNvbnN0IF95TmljZSA9IHdyaXRhYmxlKHlOaWNlKTtcblx0Y29uc3QgX3pOaWNlID0gd3JpdGFibGUoek5pY2UpO1xuXHRjb25zdCBfck5pY2UgPSB3cml0YWJsZShyTmljZSk7XG5cdGNvbnN0IF94UmV2ZXJzZSA9IHdyaXRhYmxlKHhSZXZlcnNlKTtcblx0Y29uc3QgX3lSZXZlcnNlID0gd3JpdGFibGUoeVJldmVyc2VWYWx1ZSk7XG5cdGNvbnN0IF96UmV2ZXJzZSA9IHdyaXRhYmxlKHpSZXZlcnNlKTtcblx0Y29uc3QgX3JSZXZlcnNlID0gd3JpdGFibGUoclJldmVyc2UpO1xuXHRjb25zdCBfeFBhZGRpbmcgPSB3cml0YWJsZSh4UGFkZGluZyk7XG5cdGNvbnN0IF95UGFkZGluZyA9IHdyaXRhYmxlKHlQYWRkaW5nKTtcblx0Y29uc3QgX3pQYWRkaW5nID0gd3JpdGFibGUoelBhZGRpbmcpO1xuXHRjb25zdCBfclBhZGRpbmcgPSB3cml0YWJsZShyUGFkZGluZyk7XG5cdGNvbnN0IF94UmFuZ2UgPSB3cml0YWJsZSh4UmFuZ2UpO1xuXHRjb25zdCBfeVJhbmdlID0gd3JpdGFibGUoeVJhbmdlKTtcblx0Y29uc3QgX3pSYW5nZSA9IHdyaXRhYmxlKHpSYW5nZSk7XG5cdGNvbnN0IF9yUmFuZ2UgPSB3cml0YWJsZShyUmFuZ2UpO1xuXHRjb25zdCBfeFNjYWxlID0gd3JpdGFibGUoeFNjYWxlKTtcblx0Y29uc3QgX3lTY2FsZSA9IHdyaXRhYmxlKHlTY2FsZSk7XG5cdGNvbnN0IF96U2NhbGUgPSB3cml0YWJsZSh6U2NhbGUpO1xuXHRjb25zdCBfclNjYWxlID0gd3JpdGFibGUoclNjYWxlKTtcblx0Y29uc3QgX3hEb21haW5Tb3J0ID0gd3JpdGFibGUoeERvbWFpblNvcnQpO1xuXHRjb25zdCBfeURvbWFpblNvcnQgPSB3cml0YWJsZSh5RG9tYWluU29ydCk7XG5cdGNvbnN0IF96RG9tYWluU29ydCA9IHdyaXRhYmxlKHpEb21haW5Tb3J0KTtcblx0Y29uc3QgX3JEb21haW5Tb3J0ID0gd3JpdGFibGUockRvbWFpblNvcnQpO1xuXHRjb25zdCBfY29uZmlnID0gd3JpdGFibGUoY29uZmlnKTtcblx0Y29uc3QgX2N1c3RvbSA9IHdyaXRhYmxlKGN1c3RvbSk7XG5cdGNvbnN0IF9kZXJpdmVTY2FsZXMgPSB3cml0YWJsZShkZXJpdmVTY2FsZXMpO1xuXG5cdCQ6ICRfcGVyY2VudFJhbmdlID0gcGVyY2VudFJhbmdlO1xuXHQkOiAkX2NvbnRhaW5lcldpZHRoID0gY29udGFpbmVyV2lkdGg7XG5cdCQ6ICRfY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuXHQkOiAkX2V4dGVudHMgPSBmaWx0ZXJPYmplY3QoZXh0ZW50cyk7XG5cdCQ6ICRfZGF0YSA9IGRhdGE7XG5cdCQ6ICRfZmxhdERhdGEgPSBmbGF0RGF0YSB8fCBkYXRhO1xuXHQkOiAkX3BhZGRpbmcgPSBwYWRkaW5nO1xuXHQkOiAkX3ggPSBtYWtlQWNjZXNzb3IoeCk7XG5cdCQ6ICRfeSA9IG1ha2VBY2Nlc3Nvcih5KTtcblx0JDogJF96ID0gbWFrZUFjY2Vzc29yKHopO1xuXHQkOiAkX3IgPSBtYWtlQWNjZXNzb3Iocik7XG5cdCQ6ICRfeERvbWFpbiA9IHhEb21haW47XG5cdCQ6ICRfeURvbWFpbiA9IHlEb21haW47XG5cdCQ6ICRfekRvbWFpbiA9IHpEb21haW47XG5cdCQ6ICRfckRvbWFpbiA9IHJEb21haW47XG5cdCQ6ICRfeE5pY2UgPSB4TmljZTtcblx0JDogJF95TmljZSA9IHlOaWNlO1xuXHQkOiAkX3pOaWNlID0gek5pY2U7XG5cdCQ6ICRfck5pY2UgPSByTmljZTtcblx0JDogJF94UmV2ZXJzZSA9IHhSZXZlcnNlO1xuXHQkOiAkX3lSZXZlcnNlID0geVJldmVyc2VWYWx1ZTtcblx0JDogJF96UmV2ZXJzZSA9IHpSZXZlcnNlO1xuXHQkOiAkX3JSZXZlcnNlID0gclJldmVyc2U7XG5cdCQ6ICRfeFBhZGRpbmcgPSB4UGFkZGluZztcblx0JDogJF95UGFkZGluZyA9IHlQYWRkaW5nO1xuXHQkOiAkX3pQYWRkaW5nID0gelBhZGRpbmc7XG5cdCQ6ICRfclBhZGRpbmcgPSByUGFkZGluZztcblx0JDogJF94UmFuZ2UgPSB4UmFuZ2U7XG5cdCQ6ICRfeVJhbmdlID0geVJhbmdlO1xuXHQkOiAkX3pSYW5nZSA9IHpSYW5nZTtcblx0JDogJF9yUmFuZ2UgPSByUmFuZ2U7XG5cdCQ6ICRfeFNjYWxlID0geFNjYWxlO1xuXHQkOiAkX3lTY2FsZSA9IHlTY2FsZTtcblx0JDogJF96U2NhbGUgPSB6U2NhbGU7XG5cdCQ6ICRfclNjYWxlID0gclNjYWxlO1xuXHQkOiAkX2N1c3RvbSA9IGN1c3RvbTtcblx0JDogJF9jb25maWcgPSBjb25maWc7XG5cdCQ6ICRfZGVyaXZlU2NhbGVzID0gZGVyaXZlU2NhbGVzO1xuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqIENyZWF0ZSBkZXJpdmVkIHZhbHVlc1xuXHQgKiBTdWZmaXggdGhlc2Ugd2l0aCBgX2RgXG5cdCAqL1xuXHRjb25zdCBhY3RpdmVHZXR0ZXJzX2QgPSBkZXJpdmVkKFtfeCwgX3ksIF96LCBfcl0sIChbJHgsICR5LCAkeiwgJHJdKSA9PiB7XG5cdFx0Y29uc3Qgb2JqID0ge307XG5cdFx0aWYgKCR4KSB7XG5cdFx0XHRvYmoueCA9ICR4O1xuXHRcdH1cblx0XHRpZiAoJHkpIHtcblx0XHRcdG9iai55ID0gJHk7XG5cdFx0fVxuXHRcdGlmICgkeikge1xuXHRcdFx0b2JqLnogPSAkejtcblx0XHR9XG5cdFx0aWYgKCRyKSB7XG5cdFx0XHRvYmouciA9ICRyO1xuXHRcdH1cblx0XHRyZXR1cm4gb2JqO1xuXHR9KTtcblxuXHRjb25zdCBwYWRkaW5nX2QgPSBkZXJpdmVkKFtfcGFkZGluZywgX2NvbnRhaW5lcldpZHRoLCBfY29udGFpbmVySGVpZ2h0XSwgKFskcGFkZGluZ10pID0+IHtcblx0XHRjb25zdCBkZWZhdWx0UGFkZGluZyA9IHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwIH07XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oZGVmYXVsdFBhZGRpbmcsICRwYWRkaW5nKTtcblx0fSk7XG5cblx0Y29uc3QgYm94X2QgPSBkZXJpdmVkKFxuXHRcdFtfY29udGFpbmVyV2lkdGgsIF9jb250YWluZXJIZWlnaHQsIHBhZGRpbmdfZF0sXG5cdFx0KFskY29udGFpbmVyV2lkdGgsICRjb250YWluZXJIZWlnaHQsICRwYWRkaW5nXSkgPT4ge1xuXHRcdFx0Y29uc3QgYiA9IHt9O1xuXHRcdFx0Yi50b3AgPSAkcGFkZGluZy50b3A7XG5cdFx0XHRiLnJpZ2h0ID0gJGNvbnRhaW5lcldpZHRoIC0gJHBhZGRpbmcucmlnaHQ7XG5cdFx0XHRiLmJvdHRvbSA9ICRjb250YWluZXJIZWlnaHQgLSAkcGFkZGluZy5ib3R0b207XG5cdFx0XHRiLmxlZnQgPSAkcGFkZGluZy5sZWZ0O1xuXHRcdFx0Yi53aWR0aCA9IGIucmlnaHQgLSBiLmxlZnQ7XG5cdFx0XHRiLmhlaWdodCA9IGIuYm90dG9tIC0gYi50b3A7XG5cdFx0XHRpZiAodmVyYm9zZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRpZiAoYi53aWR0aCA8PSAwICYmIGlzTW91bnRlZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHRcdCdbTGF5ZXJDYWtlXSBUYXJnZXQgZGl2IGhhcyB6ZXJvIG9yIG5lZ2F0aXZlIHdpZHRoLiBEaWQgeW91IGZvcmdldCB0byBzZXQgYW4gZXhwbGljaXQgd2lkdGggaW4gQ1NTIG9uIHRoZSBjb250YWluZXI/J1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGIuaGVpZ2h0IDw9IDAgJiYgaXNNb3VudGVkID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRcdFx0J1tMYXllckNha2VdIFRhcmdldCBkaXYgaGFzIHplcm8gb3IgbmVnYXRpdmUgaGVpZ2h0LiBEaWQgeW91IGZvcmdldCB0byBzZXQgYW4gZXhwbGljaXQgaGVpZ2h0IGluIENTUyBvbiB0aGUgY29udGFpbmVyPydcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYjtcblx0XHR9XG5cdCk7XG5cblx0Y29uc3Qgd2lkdGhfZCA9IGRlcml2ZWQoW2JveF9kXSwgKFskYm94XSkgPT4ge1xuXHRcdHJldHVybiAkYm94LndpZHRoO1xuXHR9KTtcblxuXHRjb25zdCBoZWlnaHRfZCA9IGRlcml2ZWQoW2JveF9kXSwgKFskYm94XSkgPT4ge1xuXHRcdHJldHVybiAkYm94LmhlaWdodDtcblx0fSk7XG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICogQ2FsY3VsYXRlIGV4dGVudHMgYnkgdGFraW5nIHRoZSBleHRlbnQgb2YgdGhlIGRhdGFcblx0ICogYW5kIGZpbGxpbmcgdGhhdCBpbiB3aXRoIGFueXRoaW5nIHNldCBieSB0aGUgdXNlclxuXHQgKiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBhbiBcImV4dGVudFwiIHBhc3NlZFxuXHQgKiBpbiBhcyBhIGRvbWFpbiwgd2hpY2ggY2FuIGJlIGEgcGFydGlhbCBkb21haW5cblx0ICovXG5cdGNvbnN0IGV4dGVudHNfZCA9IGRlcml2ZWQoXG5cdFx0W1xuXHRcdFx0X2ZsYXREYXRhLFxuXHRcdFx0YWN0aXZlR2V0dGVyc19kLFxuXHRcdFx0X2V4dGVudHMsXG5cdFx0XHRfeFNjYWxlLFxuXHRcdFx0X3lTY2FsZSxcblx0XHRcdF9yU2NhbGUsXG5cdFx0XHRfelNjYWxlLFxuXHRcdFx0X3hEb21haW5Tb3J0LFxuXHRcdFx0X3lEb21haW5Tb3J0LFxuXHRcdFx0X3pEb21haW5Tb3J0LFxuXHRcdFx0X3JEb21haW5Tb3J0XG5cdFx0XSxcblx0XHQoW1xuXHRcdFx0JGZsYXREYXRhLFxuXHRcdFx0JGFjdGl2ZUdldHRlcnMsXG5cdFx0XHQkZXh0ZW50cyxcblx0XHRcdCRfeFNjYWxlLFxuXHRcdFx0JF95U2NhbGUsXG5cdFx0XHQkX3JTY2FsZSxcblx0XHRcdCRfelNjYWxlLFxuXHRcdFx0JF94RG9tYWluU29ydCxcblx0XHRcdCRfeURvbWFpblNvcnQsXG5cdFx0XHQkX3pEb21haW5Tb3J0LFxuXHRcdFx0JF9yRG9tYWluU29ydFxuXHRcdF0pID0+IHtcblx0XHRcdGNvbnN0IHNjYWxlTG9va3VwID0ge1xuXHRcdFx0XHR4OiB7IHNjYWxlOiAkX3hTY2FsZSwgc29ydDogJF94RG9tYWluU29ydCB9LFxuXHRcdFx0XHR5OiB7IHNjYWxlOiAkX3lTY2FsZSwgc29ydDogJF95RG9tYWluU29ydCB9LFxuXHRcdFx0XHRyOiB7IHNjYWxlOiAkX3JTY2FsZSwgc29ydDogJF9yRG9tYWluU29ydCB9LFxuXHRcdFx0XHR6OiB7IHNjYWxlOiAkX3pTY2FsZSwgc29ydDogJF96RG9tYWluU29ydCB9XG5cdFx0XHR9O1xuXHRcdFx0Y29uc3QgZ2V0dGVycyA9IGZpbHRlck9iamVjdCgkYWN0aXZlR2V0dGVycywgJGV4dGVudHMpO1xuXHRcdFx0Y29uc3QgYWN0aXZlU2NhbGVzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKGdldHRlcnMpLm1hcChrID0+IFtrLCBzY2FsZUxvb2t1cFtrXV0pKTtcblxuXHRcdFx0aWYgKE9iamVjdC5rZXlzKGdldHRlcnMpLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgY2FsY3VsYXRlZEV4dGVudHMgPSBjYWxjU2NhbGVFeHRlbnRzKCRmbGF0RGF0YSwgZ2V0dGVycywgYWN0aXZlU2NhbGVzKTtcblx0XHRcdFx0cmV0dXJuIHsgLi4uY2FsY3VsYXRlZEV4dGVudHMsIC4uLiRleHRlbnRzIH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4ge307XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xuXG5cdGNvbnN0IHhEb21haW5fZCA9IGRlcml2ZWQoW2V4dGVudHNfZCwgX3hEb21haW5dLCBjYWxjRG9tYWluKCd4JykpO1xuXHRjb25zdCB5RG9tYWluX2QgPSBkZXJpdmVkKFtleHRlbnRzX2QsIF95RG9tYWluXSwgY2FsY0RvbWFpbigneScpKTtcblx0Y29uc3QgekRvbWFpbl9kID0gZGVyaXZlZChbZXh0ZW50c19kLCBfekRvbWFpbl0sIGNhbGNEb21haW4oJ3onKSk7XG5cdGNvbnN0IHJEb21haW5fZCA9IGRlcml2ZWQoW2V4dGVudHNfZCwgX3JEb21haW5dLCBjYWxjRG9tYWluKCdyJykpO1xuXG5cdGNvbnN0IHhTY2FsZV9kID0gZGVyaXZlZChcblx0XHRbXG5cdFx0XHRfeFNjYWxlLFxuXHRcdFx0ZXh0ZW50c19kLFxuXHRcdFx0eERvbWFpbl9kLFxuXHRcdFx0X3hQYWRkaW5nLFxuXHRcdFx0X3hOaWNlLFxuXHRcdFx0X3hSZXZlcnNlLFxuXHRcdFx0d2lkdGhfZCxcblx0XHRcdGhlaWdodF9kLFxuXHRcdFx0X3hSYW5nZSxcblx0XHRcdF9wZXJjZW50UmFuZ2Vcblx0XHRdLFxuXHRcdGNyZWF0ZVNjYWxlKCd4Jylcblx0KTtcblx0Y29uc3QgeEdldF9kID0gZGVyaXZlZChbX3gsIHhTY2FsZV9kXSwgY3JlYXRlR2V0dGVyKTtcblxuXHRjb25zdCB5U2NhbGVfZCA9IGRlcml2ZWQoXG5cdFx0W1xuXHRcdFx0X3lTY2FsZSxcblx0XHRcdGV4dGVudHNfZCxcblx0XHRcdHlEb21haW5fZCxcblx0XHRcdF95UGFkZGluZyxcblx0XHRcdF95TmljZSxcblx0XHRcdF95UmV2ZXJzZSxcblx0XHRcdHdpZHRoX2QsXG5cdFx0XHRoZWlnaHRfZCxcblx0XHRcdF95UmFuZ2UsXG5cdFx0XHRfcGVyY2VudFJhbmdlXG5cdFx0XSxcblx0XHRjcmVhdGVTY2FsZSgneScpXG5cdCk7XG5cdGNvbnN0IHlHZXRfZCA9IGRlcml2ZWQoW195LCB5U2NhbGVfZF0sIGNyZWF0ZUdldHRlcik7XG5cblx0Y29uc3QgelNjYWxlX2QgPSBkZXJpdmVkKFxuXHRcdFtcblx0XHRcdF96U2NhbGUsXG5cdFx0XHRleHRlbnRzX2QsXG5cdFx0XHR6RG9tYWluX2QsXG5cdFx0XHRfelBhZGRpbmcsXG5cdFx0XHRfek5pY2UsXG5cdFx0XHRfelJldmVyc2UsXG5cdFx0XHR3aWR0aF9kLFxuXHRcdFx0aGVpZ2h0X2QsXG5cdFx0XHRfelJhbmdlLFxuXHRcdFx0X3BlcmNlbnRSYW5nZVxuXHRcdF0sXG5cdFx0Y3JlYXRlU2NhbGUoJ3onKVxuXHQpO1xuXHRjb25zdCB6R2V0X2QgPSBkZXJpdmVkKFtfeiwgelNjYWxlX2RdLCBjcmVhdGVHZXR0ZXIpO1xuXG5cdGNvbnN0IHJTY2FsZV9kID0gZGVyaXZlZChcblx0XHRbXG5cdFx0XHRfclNjYWxlLFxuXHRcdFx0ZXh0ZW50c19kLFxuXHRcdFx0ckRvbWFpbl9kLFxuXHRcdFx0X3JQYWRkaW5nLFxuXHRcdFx0X3JOaWNlLFxuXHRcdFx0X3JSZXZlcnNlLFxuXHRcdFx0d2lkdGhfZCxcblx0XHRcdGhlaWdodF9kLFxuXHRcdFx0X3JSYW5nZSxcblx0XHRcdF9wZXJjZW50UmFuZ2Vcblx0XHRdLFxuXHRcdGNyZWF0ZVNjYWxlKCdyJylcblx0KTtcblx0Y29uc3QgckdldF9kID0gZGVyaXZlZChbX3IsIHJTY2FsZV9kXSwgY3JlYXRlR2V0dGVyKTtcblxuXHQvLyBDcmVhdGUgbmV3IF9Eb21haW5zIGluIGNhc2Ugd2UgcmFuIGAubmljZSgpYCBvdmVyIG91ciBkb21haW4gb24gc2NhbGUgaW5pdGlhbGl6YXRpb25cblx0Y29uc3QgeERvbWFpbl9kX3Bvc3NpYmx5X25pY2UgPSBkZXJpdmVkKHhTY2FsZV9kLCAkeFNjYWxlX2QgPT4gJHhTY2FsZV9kLmRvbWFpbigpKTtcblx0Y29uc3QgeURvbWFpbl9kX3Bvc3NpYmx5X25pY2UgPSBkZXJpdmVkKHlTY2FsZV9kLCAkeVNjYWxlX2QgPT4gJHlTY2FsZV9kLmRvbWFpbigpKTtcblx0Y29uc3QgekRvbWFpbl9kX3Bvc3NpYmx5X25pY2UgPSBkZXJpdmVkKHpTY2FsZV9kLCAkelNjYWxlX2QgPT4gJHpTY2FsZV9kLmRvbWFpbigpKTtcblx0Y29uc3QgckRvbWFpbl9kX3Bvc3NpYmx5X25pY2UgPSBkZXJpdmVkKHJTY2FsZV9kLCAkclNjYWxlX2QgPT4gJHJTY2FsZV9kLmRvbWFpbigpKTtcblxuXHRjb25zdCB4UmFuZ2VfZCA9IGRlcml2ZWQoW3hTY2FsZV9kXSwgZ2V0UmFuZ2UpO1xuXHRjb25zdCB5UmFuZ2VfZCA9IGRlcml2ZWQoW3lTY2FsZV9kXSwgZ2V0UmFuZ2UpO1xuXHRjb25zdCB6UmFuZ2VfZCA9IGRlcml2ZWQoW3pTY2FsZV9kXSwgZ2V0UmFuZ2UpO1xuXHRjb25zdCByUmFuZ2VfZCA9IGRlcml2ZWQoW3JTY2FsZV9kXSwgZ2V0UmFuZ2UpO1xuXG5cdGNvbnN0IGFzcGVjdFJhdGlvX2QgPSBkZXJpdmVkKFt3aWR0aF9kLCBoZWlnaHRfZF0sIChbJHdpZHRoLCAkaGVpZ2h0XSkgPT4ge1xuXHRcdHJldHVybiAkd2lkdGggLyAkaGVpZ2h0O1xuXHR9KTtcblxuXHRjb25zdCBkZXJpdmVkU2NhbGVzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKCRfZGVyaXZlU2NhbGVzKS5tYXAoKFtuYW1lLCBmbl0pID0+IHtcblx0XHRyZXR1cm4gW25hbWUsIHdyaXRhYmxlKGZuKHtcblx0XHRcdHhTY2FsZTogJHhTY2FsZV9kLmNvcHkoKSxcblx0XHRcdHlTY2FsZTogJHlTY2FsZV9kLmNvcHkoKSxcblx0XHRcdHpTY2FsZTogJHpTY2FsZV9kLmNvcHkoKSxcblx0XHRcdHJTY2FsZTogJHJTY2FsZV9kLmNvcHkoKVxuXHRcdH0pKV1cblx0fSkpO1xuXG5cdCQ6IGlmICgkX2Rlcml2ZVNjYWxlcykge1xuXHRcdGZvciAoY29uc3QgW25hbWUsIGZuXSBvZiBPYmplY3QuZW50cmllcygkX2Rlcml2ZVNjYWxlcykpIHtcblx0XHRcdGRlcml2ZWRTY2FsZXNbbmFtZV0uc2V0KGZuKHtcblx0XHRcdFx0eFNjYWxlOiAkeFNjYWxlX2QuY29weSgpLFxuXHRcdFx0XHR5U2NhbGU6ICR5U2NhbGVfZC5jb3B5KCksXG5cdFx0XHRcdHpTY2FsZTogJHpTY2FsZV9kLmNvcHkoKSxcblx0XHRcdFx0clNjYWxlOiAkclNjYWxlX2QuY29weSgpXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHR9XG5cblx0JDogY29udGV4dCA9IHtcblx0XHQuLi5kZXJpdmVkU2NhbGVzLFxuXHRcdGFjdGl2ZUdldHRlcnM6IGFjdGl2ZUdldHRlcnNfZCxcblx0XHR3aWR0aDogd2lkdGhfZCxcblx0XHRoZWlnaHQ6IGhlaWdodF9kLFxuXHRcdHBlcmNlbnRSYW5nZTogX3BlcmNlbnRSYW5nZSxcblx0XHRhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW9fZCxcblx0XHRjb250YWluZXJXaWR0aDogX2NvbnRhaW5lcldpZHRoLFxuXHRcdGNvbnRhaW5lckhlaWdodDogX2NvbnRhaW5lckhlaWdodCxcblx0XHR4OiBfeCxcblx0XHR5OiBfeSxcblx0XHR6OiBfeixcblx0XHRyOiBfcixcblx0XHRjdXN0b206IF9jdXN0b20sXG5cdFx0ZGF0YTogX2RhdGEsXG5cdFx0eE5pY2U6IF94TmljZSxcblx0XHR5TmljZTogX3lOaWNlLFxuXHRcdHpOaWNlOiBfek5pY2UsXG5cdFx0ck5pY2U6IF9yTmljZSxcblx0XHR4RG9tYWluU29ydDogX3hEb21haW5Tb3J0LFxuXHRcdHlEb21haW5Tb3J0OiBfeURvbWFpblNvcnQsXG5cdFx0ekRvbWFpblNvcnQ6IF96RG9tYWluU29ydCxcblx0XHRyRG9tYWluU29ydDogX3JEb21haW5Tb3J0LFxuXHRcdHhSZXZlcnNlOiBfeFJldmVyc2UsXG5cdFx0eVJldmVyc2U6IF95UmV2ZXJzZSxcblx0XHR6UmV2ZXJzZTogX3pSZXZlcnNlLFxuXHRcdHJSZXZlcnNlOiBfclJldmVyc2UsXG5cdFx0eFBhZGRpbmc6IF94UGFkZGluZyxcblx0XHR5UGFkZGluZzogX3lQYWRkaW5nLFxuXHRcdHpQYWRkaW5nOiBfelBhZGRpbmcsXG5cdFx0clBhZGRpbmc6IF9yUGFkZGluZyxcblx0XHRwYWRkaW5nOiBwYWRkaW5nX2QsXG5cdFx0ZmxhdERhdGE6IF9mbGF0RGF0YSxcblx0XHRleHRlbnRzOiBleHRlbnRzX2QsXG5cdFx0eERvbWFpbjogeERvbWFpbl9kX3Bvc3NpYmx5X25pY2UsXG5cdFx0eURvbWFpbjogeURvbWFpbl9kX3Bvc3NpYmx5X25pY2UsXG5cdFx0ekRvbWFpbjogekRvbWFpbl9kX3Bvc3NpYmx5X25pY2UsXG5cdFx0ckRvbWFpbjogckRvbWFpbl9kX3Bvc3NpYmx5X25pY2UsXG5cdFx0eFJhbmdlOiB4UmFuZ2VfZCxcblx0XHR5UmFuZ2U6IHlSYW5nZV9kLFxuXHRcdHpSYW5nZTogelJhbmdlX2QsXG5cdFx0clJhbmdlOiByUmFuZ2VfZCxcblx0XHRjb25maWc6IF9jb25maWcsXG5cdFx0eFNjYWxlOiB4U2NhbGVfZCxcblx0XHR4R2V0OiB4R2V0X2QsXG5cdFx0eVNjYWxlOiB5U2NhbGVfZCxcblx0XHR5R2V0OiB5R2V0X2QsXG5cdFx0elNjYWxlOiB6U2NhbGVfZCxcblx0XHR6R2V0OiB6R2V0X2QsXG5cdFx0clNjYWxlOiByU2NhbGVfZCxcblx0XHRyR2V0OiByR2V0X2Rcblx0fTtcblxuXHQkOiBzZXRDb250ZXh0KCdMYXllckNha2UnLCBjb250ZXh0KTtcblxuXHQkOiBpZiAoJGJveF9kICYmIGRlYnVnID09PSB0cnVlICYmIChzc3IgPT09IHRydWUgfHwgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpKSB7XG5cdFx0Ly8gQ2FsbCB0aGlzIGFzIGEgZGVib3VuY2Ugc28gdGhhdCBpdCBkb2Vzbid0IGdldCBjYWxsZWQgbXVsdGlwbGUgdGltZXMgYXMgdGhlc2UgdmFycyBnZXQgZmlsbGVkIGluXG5cdFx0cHJpbnREZWJ1Z19kZWJvdW5jZWQoe1xuXHRcdFx0ZGF0YTogJF9kYXRhLFxuXHRcdFx0ZmxhdERhdGE6IHR5cGVvZiBmbGF0RGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyAkX2ZsYXREYXRhIDogbnVsbCxcblx0XHRcdGJvdW5kaW5nQm94OiAkYm94X2QsXG5cdFx0XHRhY3RpdmVHZXR0ZXJzOiAkYWN0aXZlR2V0dGVyc19kLFxuXHRcdFx0eDogY29uZmlnLngsXG5cdFx0XHR5OiBjb25maWcueSxcblx0XHRcdHo6IGNvbmZpZy56LFxuXHRcdFx0cjogY29uZmlnLnIsXG5cdFx0XHR4U2NhbGU6ICR4U2NhbGVfZCxcblx0XHRcdHlTY2FsZTogJHlTY2FsZV9kLFxuXHRcdFx0elNjYWxlOiAkelNjYWxlX2QsXG5cdFx0XHRyU2NhbGU6ICRyU2NhbGVfZFxuXHRcdH0pO1xuXHR9XG48L3NjcmlwdD5cblxueyNpZiBzc3IgPT09IHRydWUgfHwgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCd9XG5cdDxkaXZcblx0XHRiaW5kOnRoaXM9e2VsZW1lbnR9XG5cdFx0Y2xhc3M9XCJsYXllcmNha2UtY29udGFpbmVyXCJcblx0XHRzdHlsZTpwb3NpdGlvblxuXHRcdHN0eWxlOnRvcD17cG9zaXRpb24gPT09ICdhYnNvbHV0ZScgPyAnMCcgOiBudWxsfVxuXHRcdHN0eWxlOnJpZ2h0PXtwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJyA/ICcwJyA6IG51bGx9XG5cdFx0c3R5bGU6Ym90dG9tPXtwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJyA/ICcwJyA6IG51bGx9XG5cdFx0c3R5bGU6bGVmdD17cG9zaXRpb24gPT09ICdhYnNvbHV0ZScgPyAnMCcgOiBudWxsfVxuXHRcdHN0eWxlOnBvaW50ZXItZXZlbnRzPXtwb2ludGVyRXZlbnRzID09PSBmYWxzZSA/ICdub25lJyA6IG51bGx9XG5cdFx0YmluZDpjbGllbnRXaWR0aD17Y29udGFpbmVyV2lkdGh9XG5cdFx0YmluZDpjbGllbnRIZWlnaHQ9e2NvbnRhaW5lckhlaWdodH1cblx0PlxuXHRcdDxzbG90XG5cdFx0XHR7ZWxlbWVudH1cblx0XHRcdHdpZHRoPXskd2lkdGhfZH1cblx0XHRcdGhlaWdodD17JGhlaWdodF9kfVxuXHRcdFx0YXNwZWN0UmF0aW89eyRhc3BlY3RSYXRpb19kfVxuXHRcdFx0Y29udGFpbmVyV2lkdGg9eyRfY29udGFpbmVyV2lkdGh9XG5cdFx0XHRjb250YWluZXJIZWlnaHQ9eyRfY29udGFpbmVySGVpZ2h0fVxuXHRcdFx0YWN0aXZlR2V0dGVycz17JGFjdGl2ZUdldHRlcnNfZH1cblx0XHRcdHBlcmNlbnRSYW5nZT17JF9wZXJjZW50UmFuZ2V9XG5cdFx0XHR4PXskX3h9XG5cdFx0XHR5PXskX3l9XG5cdFx0XHR6PXskX3p9XG5cdFx0XHRyPXskX3J9XG5cdFx0XHRjdXN0b209eyRfY3VzdG9tfVxuXHRcdFx0ZGF0YT17JF9kYXRhfVxuXHRcdFx0eE5pY2U9eyRfeE5pY2V9XG5cdFx0XHR5TmljZT17JF95TmljZX1cblx0XHRcdHpOaWNlPXskX3pOaWNlfVxuXHRcdFx0ck5pY2U9eyRfck5pY2V9XG5cdFx0XHR4RG9tYWluU29ydD17JF94RG9tYWluU29ydH1cblx0XHRcdHlEb21haW5Tb3J0PXskX3lEb21haW5Tb3J0fVxuXHRcdFx0ekRvbWFpblNvcnQ9eyRfekRvbWFpblNvcnR9XG5cdFx0XHRyRG9tYWluU29ydD17JF9yRG9tYWluU29ydH1cblx0XHRcdHhSZXZlcnNlPXskX3hSZXZlcnNlfVxuXHRcdFx0eVJldmVyc2U9eyRfeVJldmVyc2V9XG5cdFx0XHR6UmV2ZXJzZT17JF96UmV2ZXJzZX1cblx0XHRcdHJSZXZlcnNlPXskX3JSZXZlcnNlfVxuXHRcdFx0eFBhZGRpbmc9eyRfeFBhZGRpbmd9XG5cdFx0XHR5UGFkZGluZz17JF95UGFkZGluZ31cblx0XHRcdHpQYWRkaW5nPXskX3pQYWRkaW5nfVxuXHRcdFx0clBhZGRpbmc9eyRfclBhZGRpbmd9XG5cdFx0XHRwYWRkaW5nPXskcGFkZGluZ19kfVxuXHRcdFx0ZmxhdERhdGE9eyRfZmxhdERhdGF9XG5cdFx0XHRleHRlbnRzPXskZXh0ZW50c19kfVxuXHRcdFx0eERvbWFpbj17JHhEb21haW5fZH1cblx0XHRcdHlEb21haW49eyR5RG9tYWluX2R9XG5cdFx0XHR6RG9tYWluPXskekRvbWFpbl9kfVxuXHRcdFx0ckRvbWFpbj17JHJEb21haW5fZH1cblx0XHRcdHhSYW5nZT17JHhSYW5nZV9kfVxuXHRcdFx0eVJhbmdlPXskeVJhbmdlX2R9XG5cdFx0XHR6UmFuZ2U9eyR6UmFuZ2VfZH1cblx0XHRcdHJSYW5nZT17JHJSYW5nZV9kfVxuXHRcdFx0Y29uZmlnPXskX2NvbmZpZ31cblx0XHRcdHhTY2FsZT17JHhTY2FsZV9kfVxuXHRcdFx0eEdldD17JHhHZXRfZH1cblx0XHRcdHlTY2FsZT17JHlTY2FsZV9kfVxuXHRcdFx0eUdldD17JHlHZXRfZH1cblx0XHRcdHpTY2FsZT17JHpTY2FsZV9kfVxuXHRcdFx0ekdldD17JHpHZXRfZH1cblx0XHRcdHJTY2FsZT17JHJTY2FsZV9kfVxuXHRcdFx0ckdldD17JHJHZXRfZH1cblx0XHQvPlxuXHQ8L2Rpdj5cbnsvaWZ9XG5cbjxzdHlsZT5cblx0LmxheWVyY2FrZS1jb250YWluZXIsXG5cdC5sYXllcmNha2UtY29udGFpbmVyIDpnbG9iYWwoKikge1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdH1cblx0LmxheWVyY2FrZS1jb250YWluZXIge1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0fVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFpbkJDLGtDQUFvQixDQUNwQixrQ0FBb0IsQ0FBUyxDQUFHLENBQy9CLFVBQVUsQ0FBRSxVQUNiLENBQ0Esa0NBQXFCLENBQ3BCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQ1QifQ== */");
}
var get_default_slot_changes = (dirty) => ({
  element: dirty[0] & /*element*/
  4,
  width: dirty[1] & /*$width_d*/
  8,
  height: dirty[1] & /*$height_d*/
  16,
  aspectRatio: dirty[1] & /*$aspectRatio_d*/
  32,
  containerWidth: dirty[1] & /*$_containerWidth*/
  2,
  containerHeight: dirty[1] & /*$_containerHeight*/
  1,
  activeGetters: dirty[0] & /*$activeGetters_d*/
  1024,
  percentRange: dirty[1] & /*$_percentRange*/
  4,
  x: dirty[0] & /*$_x*/
  1073741824,
  y: dirty[0] & /*$_y*/
  536870912,
  z: dirty[0] & /*$_z*/
  268435456,
  r: dirty[0] & /*$_r*/
  134217728,
  custom: dirty[0] & /*$_custom*/
  16384,
  data: dirty[0] & /*$_data*/
  4096,
  xNice: dirty[0] & /*$_xNice*/
  67108864,
  yNice: dirty[0] & /*$_yNice*/
  33554432,
  zNice: dirty[0] & /*$_zNice*/
  16777216,
  rNice: dirty[0] & /*$_rNice*/
  8388608,
  xDomainSort: dirty[1] & /*$_xDomainSort*/
  64,
  yDomainSort: dirty[1] & /*$_yDomainSort*/
  128,
  zDomainSort: dirty[1] & /*$_zDomainSort*/
  256,
  rDomainSort: dirty[1] & /*$_rDomainSort*/
  512,
  xReverse: dirty[0] & /*$_xReverse*/
  4194304,
  yReverse: dirty[0] & /*$_yReverse*/
  2097152,
  zReverse: dirty[0] & /*$_zReverse*/
  1048576,
  rReverse: dirty[0] & /*$_rReverse*/
  524288,
  xPadding: dirty[0] & /*$_xPadding*/
  262144,
  yPadding: dirty[0] & /*$_yPadding*/
  131072,
  zPadding: dirty[0] & /*$_zPadding*/
  65536,
  rPadding: dirty[0] & /*$_rPadding*/
  32768,
  padding: dirty[1] & /*$padding_d*/
  1024,
  flatData: dirty[0] & /*$_flatData*/
  2048,
  extents: dirty[1] & /*$extents_d*/
  2048,
  xDomain: dirty[1] & /*$xDomain_d*/
  4096,
  yDomain: dirty[1] & /*$yDomain_d*/
  8192,
  zDomain: dirty[1] & /*$zDomain_d*/
  16384,
  rDomain: dirty[1] & /*$rDomain_d*/
  32768,
  xRange: dirty[1] & /*$xRange_d*/
  65536,
  yRange: dirty[1] & /*$yRange_d*/
  131072,
  zRange: dirty[1] & /*$zRange_d*/
  262144,
  rRange: dirty[1] & /*$rRange_d*/
  524288,
  config: dirty[0] & /*$_config*/
  8192,
  xScale: dirty[0] & /*$xScale_d*/
  512,
  xGet: dirty[1] & /*$xGet_d*/
  1048576,
  yScale: dirty[0] & /*$yScale_d*/
  256,
  yGet: dirty[1] & /*$yGet_d*/
  2097152,
  zScale: dirty[0] & /*$zScale_d*/
  128,
  zGet: dirty[1] & /*$zGet_d*/
  4194304,
  rScale: dirty[0] & /*$rScale_d*/
  64,
  rGet: dirty[1] & /*$rGet_d*/
  8388608
});
var get_default_slot_context = (ctx) => ({
  element: (
    /*element*/
    ctx[2]
  ),
  width: (
    /*$width_d*/
    ctx[34]
  ),
  height: (
    /*$height_d*/
    ctx[35]
  ),
  aspectRatio: (
    /*$aspectRatio_d*/
    ctx[36]
  ),
  containerWidth: (
    /*$_containerWidth*/
    ctx[32]
  ),
  containerHeight: (
    /*$_containerHeight*/
    ctx[31]
  ),
  activeGetters: (
    /*$activeGetters_d*/
    ctx[10]
  ),
  percentRange: (
    /*$_percentRange*/
    ctx[33]
  ),
  x: (
    /*$_x*/
    ctx[30]
  ),
  y: (
    /*$_y*/
    ctx[29]
  ),
  z: (
    /*$_z*/
    ctx[28]
  ),
  r: (
    /*$_r*/
    ctx[27]
  ),
  custom: (
    /*$_custom*/
    ctx[14]
  ),
  data: (
    /*$_data*/
    ctx[12]
  ),
  xNice: (
    /*$_xNice*/
    ctx[26]
  ),
  yNice: (
    /*$_yNice*/
    ctx[25]
  ),
  zNice: (
    /*$_zNice*/
    ctx[24]
  ),
  rNice: (
    /*$_rNice*/
    ctx[23]
  ),
  xDomainSort: (
    /*$_xDomainSort*/
    ctx[37]
  ),
  yDomainSort: (
    /*$_yDomainSort*/
    ctx[38]
  ),
  zDomainSort: (
    /*$_zDomainSort*/
    ctx[39]
  ),
  rDomainSort: (
    /*$_rDomainSort*/
    ctx[40]
  ),
  xReverse: (
    /*$_xReverse*/
    ctx[22]
  ),
  yReverse: (
    /*$_yReverse*/
    ctx[21]
  ),
  zReverse: (
    /*$_zReverse*/
    ctx[20]
  ),
  rReverse: (
    /*$_rReverse*/
    ctx[19]
  ),
  xPadding: (
    /*$_xPadding*/
    ctx[18]
  ),
  yPadding: (
    /*$_yPadding*/
    ctx[17]
  ),
  zPadding: (
    /*$_zPadding*/
    ctx[16]
  ),
  rPadding: (
    /*$_rPadding*/
    ctx[15]
  ),
  padding: (
    /*$padding_d*/
    ctx[41]
  ),
  flatData: (
    /*$_flatData*/
    ctx[11]
  ),
  extents: (
    /*$extents_d*/
    ctx[42]
  ),
  xDomain: (
    /*$xDomain_d*/
    ctx[43]
  ),
  yDomain: (
    /*$yDomain_d*/
    ctx[44]
  ),
  zDomain: (
    /*$zDomain_d*/
    ctx[45]
  ),
  rDomain: (
    /*$rDomain_d*/
    ctx[46]
  ),
  xRange: (
    /*$xRange_d*/
    ctx[47]
  ),
  yRange: (
    /*$yRange_d*/
    ctx[48]
  ),
  zRange: (
    /*$zRange_d*/
    ctx[49]
  ),
  rRange: (
    /*$rRange_d*/
    ctx[50]
  ),
  config: (
    /*$_config*/
    ctx[13]
  ),
  xScale: (
    /*$xScale_d*/
    ctx[9]
  ),
  xGet: (
    /*$xGet_d*/
    ctx[51]
  ),
  yScale: (
    /*$yScale_d*/
    ctx[8]
  ),
  yGet: (
    /*$yGet_d*/
    ctx[52]
  ),
  zScale: (
    /*$zScale_d*/
    ctx[7]
  ),
  zGet: (
    /*$zGet_d*/
    ctx[53]
  ),
  rScale: (
    /*$rScale_d*/
    ctx[6]
  ),
  rGet: (
    /*$rGet_d*/
    ctx[54]
  )
});
function create_if_block(ctx) {
  let div;
  let div_resize_listener;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[169].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[168],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "layercake-container svelte-vhzpsp");
      add_render_callback(() => (
        /*div_elementresize_handler*/
        ctx[171].call(div)
      ));
      set_style(
        div,
        "position",
        /*position*/
        ctx[5]
      );
      set_style(
        div,
        "top",
        /*position*/
        ctx[5] === "absolute" ? "0" : null
      );
      set_style(
        div,
        "right",
        /*position*/
        ctx[5] === "absolute" ? "0" : null
      );
      set_style(
        div,
        "bottom",
        /*position*/
        ctx[5] === "absolute" ? "0" : null
      );
      set_style(
        div,
        "left",
        /*position*/
        ctx[5] === "absolute" ? "0" : null
      );
      set_style(
        div,
        "pointer-events",
        /*pointerEvents*/
        ctx[4] === false ? "none" : null
      );
      add_location(div, file, 557, 1, 25284);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[170](div);
      div_resize_listener = add_iframe_resize_listener(
        div,
        /*div_elementresize_handler*/
        ctx[171].bind(div)
      );
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*element, $activeGetters_d, $_x, $_y, $_z, $_r, $_custom, $_data, $_xNice, $_yNice, $_zNice, $_rNice, $_xReverse, $_yReverse, $_zReverse, $_rReverse, $_xPadding, $_yPadding, $_zPadding, $_rPadding, $_flatData, $_config, $xScale_d, $yScale_d, $zScale_d, $rScale_d*/
        2147483588 | dirty[1] & /*$width_d, $height_d, $aspectRatio_d, $_containerWidth, $_containerHeight, $_percentRange, $_xDomainSort, $_yDomainSort, $_zDomainSort, $_rDomainSort, $padding_d, $extents_d, $xDomain_d, $yDomain_d, $zDomain_d, $rDomain_d, $xRange_d, $yRange_d, $zRange_d, $rRange_d, $xGet_d, $yGet_d, $zGet_d, $rGet_d*/
        16777215 | dirty[5] & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[168],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[168]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[168],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      if (dirty[0] & /*position*/
      32) {
        set_style(
          div,
          "position",
          /*position*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*position*/
      32) {
        set_style(
          div,
          "top",
          /*position*/
          ctx2[5] === "absolute" ? "0" : null
        );
      }
      if (dirty[0] & /*position*/
      32) {
        set_style(
          div,
          "right",
          /*position*/
          ctx2[5] === "absolute" ? "0" : null
        );
      }
      if (dirty[0] & /*position*/
      32) {
        set_style(
          div,
          "bottom",
          /*position*/
          ctx2[5] === "absolute" ? "0" : null
        );
      }
      if (dirty[0] & /*position*/
      32) {
        set_style(
          div,
          "left",
          /*position*/
          ctx2[5] === "absolute" ? "0" : null
        );
      }
      if (dirty[0] & /*pointerEvents*/
      16) {
        set_style(
          div,
          "pointer-events",
          /*pointerEvents*/
          ctx2[4] === false ? "none" : null
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[170](null);
      div_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(557:0) {#if ssr === true || typeof window !== 'undefined'}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*ssr*/
    (ctx[3] === true || typeof window !== "undefined") && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*ssr*/
        ctx2[3] === true || typeof window !== "undefined"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*ssr*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let yReverseValue;
  let context;
  let $rScale_d;
  let $zScale_d;
  let $yScale_d;
  let $xScale_d;
  let $activeGetters_d;
  let $box_d;
  let $_flatData;
  let $_data;
  let $_deriveScales;
  let $_config;
  let $_custom;
  let $_rScale;
  let $_zScale;
  let $_yScale;
  let $_xScale;
  let $_rRange;
  let $_zRange;
  let $_yRange;
  let $_xRange;
  let $_rPadding;
  let $_zPadding;
  let $_yPadding;
  let $_xPadding;
  let $_rReverse;
  let $_zReverse;
  let $_yReverse;
  let $_xReverse;
  let $_rNice;
  let $_zNice;
  let $_yNice;
  let $_xNice;
  let $_rDomain;
  let $_zDomain;
  let $_yDomain;
  let $_xDomain;
  let $_r;
  let $_z;
  let $_y;
  let $_x;
  let $_padding;
  let $_extents;
  let $_containerHeight;
  let $_containerWidth;
  let $_percentRange;
  let $width_d;
  let $height_d;
  let $aspectRatio_d;
  let $_xDomainSort;
  let $_yDomainSort;
  let $_zDomainSort;
  let $_rDomainSort;
  let $padding_d;
  let $extents_d;
  let $xDomain_d;
  let $yDomain_d;
  let $zDomain_d;
  let $rDomain_d;
  let $xRange_d;
  let $yRange_d;
  let $zRange_d;
  let $rRange_d;
  let $xGet_d;
  let $yGet_d;
  let $zGet_d;
  let $rGet_d;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LayerCake", slots, ["default"]);
  const printDebug_debounced = debounce(printDebug, 200);
  let { ssr = false } = $$props;
  let { pointerEvents = true } = $$props;
  let { position = "relative" } = $$props;
  let { percentRange = false } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { containerWidth = width || 100 } = $$props;
  let { containerHeight = height || 100 } = $$props;
  let { element: element2 = void 0 } = $$props;
  let { x = void 0 } = $$props;
  let { y = void 0 } = $$props;
  let { z = void 0 } = $$props;
  let { r = void 0 } = $$props;
  let { data = [] } = $$props;
  let { xDomain = void 0 } = $$props;
  let { yDomain = void 0 } = $$props;
  let { zDomain = void 0 } = $$props;
  let { rDomain = void 0 } = $$props;
  let { xNice = false } = $$props;
  let { yNice = false } = $$props;
  let { zNice = false } = $$props;
  let { rNice = false } = $$props;
  let { xPadding = void 0 } = $$props;
  let { yPadding = void 0 } = $$props;
  let { zPadding = void 0 } = $$props;
  let { rPadding = void 0 } = $$props;
  let { xScale = defaultScales_default.x } = $$props;
  let { yScale = defaultScales_default.y } = $$props;
  let { zScale = defaultScales_default.z } = $$props;
  let { rScale = defaultScales_default.r } = $$props;
  let { xRange = void 0 } = $$props;
  let { yRange = void 0 } = $$props;
  let { zRange = void 0 } = $$props;
  let { rRange = void 0 } = $$props;
  let { xReverse = false } = $$props;
  let { yReverse = void 0 } = $$props;
  let { zReverse = false } = $$props;
  let { rReverse = false } = $$props;
  let { xDomainSort = true } = $$props;
  let { yDomainSort = true } = $$props;
  let { zDomainSort = true } = $$props;
  let { rDomainSort = true } = $$props;
  let { padding = {} } = $$props;
  let { extents = {} } = $$props;
  let { deriveScales = {} } = $$props;
  let { flatData = void 0 } = $$props;
  let { custom = {} } = $$props;
  let { debug = false } = $$props;
  let { verbose = true } = $$props;
  let isMounted = false;
  onMount(() => {
    isMounted = true;
  });
  const config = {};
  const _percentRange = writable(percentRange);
  validate_store(_percentRange, "_percentRange");
  component_subscribe($$self, _percentRange, (value) => $$invalidate(33, $_percentRange = value));
  const _containerWidth = writable(containerWidth);
  validate_store(_containerWidth, "_containerWidth");
  component_subscribe($$self, _containerWidth, (value) => $$invalidate(32, $_containerWidth = value));
  const _containerHeight = writable(containerHeight);
  validate_store(_containerHeight, "_containerHeight");
  component_subscribe($$self, _containerHeight, (value) => $$invalidate(31, $_containerHeight = value));
  const _extents = writable(filterObject(extents));
  validate_store(_extents, "_extents");
  component_subscribe($$self, _extents, (value) => $$invalidate(186, $_extents = value));
  const _data = writable(data);
  validate_store(_data, "_data");
  component_subscribe($$self, _data, (value) => $$invalidate(12, $_data = value));
  const _flatData = writable(flatData || data);
  validate_store(_flatData, "_flatData");
  component_subscribe($$self, _flatData, (value) => $$invalidate(11, $_flatData = value));
  const _padding = writable(padding);
  validate_store(_padding, "_padding");
  component_subscribe($$self, _padding, (value) => $$invalidate(185, $_padding = value));
  const _x = writable(makeAccessor(x));
  validate_store(_x, "_x");
  component_subscribe($$self, _x, (value) => $$invalidate(30, $_x = value));
  const _y = writable(makeAccessor(y));
  validate_store(_y, "_y");
  component_subscribe($$self, _y, (value) => $$invalidate(29, $_y = value));
  const _z = writable(makeAccessor(z));
  validate_store(_z, "_z");
  component_subscribe($$self, _z, (value) => $$invalidate(28, $_z = value));
  const _r = writable(makeAccessor(r));
  validate_store(_r, "_r");
  component_subscribe($$self, _r, (value) => $$invalidate(27, $_r = value));
  const _xDomain = writable(xDomain);
  validate_store(_xDomain, "_xDomain");
  component_subscribe($$self, _xDomain, (value) => $$invalidate(184, $_xDomain = value));
  const _yDomain = writable(yDomain);
  validate_store(_yDomain, "_yDomain");
  component_subscribe($$self, _yDomain, (value) => $$invalidate(183, $_yDomain = value));
  const _zDomain = writable(zDomain);
  validate_store(_zDomain, "_zDomain");
  component_subscribe($$self, _zDomain, (value) => $$invalidate(182, $_zDomain = value));
  const _rDomain = writable(rDomain);
  validate_store(_rDomain, "_rDomain");
  component_subscribe($$self, _rDomain, (value) => $$invalidate(181, $_rDomain = value));
  const _xNice = writable(xNice);
  validate_store(_xNice, "_xNice");
  component_subscribe($$self, _xNice, (value) => $$invalidate(26, $_xNice = value));
  const _yNice = writable(yNice);
  validate_store(_yNice, "_yNice");
  component_subscribe($$self, _yNice, (value) => $$invalidate(25, $_yNice = value));
  const _zNice = writable(zNice);
  validate_store(_zNice, "_zNice");
  component_subscribe($$self, _zNice, (value) => $$invalidate(24, $_zNice = value));
  const _rNice = writable(rNice);
  validate_store(_rNice, "_rNice");
  component_subscribe($$self, _rNice, (value) => $$invalidate(23, $_rNice = value));
  const _xReverse = writable(xReverse);
  validate_store(_xReverse, "_xReverse");
  component_subscribe($$self, _xReverse, (value) => $$invalidate(22, $_xReverse = value));
  const _yReverse = writable(yReverseValue);
  validate_store(_yReverse, "_yReverse");
  component_subscribe($$self, _yReverse, (value) => $$invalidate(21, $_yReverse = value));
  const _zReverse = writable(zReverse);
  validate_store(_zReverse, "_zReverse");
  component_subscribe($$self, _zReverse, (value) => $$invalidate(20, $_zReverse = value));
  const _rReverse = writable(rReverse);
  validate_store(_rReverse, "_rReverse");
  component_subscribe($$self, _rReverse, (value) => $$invalidate(19, $_rReverse = value));
  const _xPadding = writable(xPadding);
  validate_store(_xPadding, "_xPadding");
  component_subscribe($$self, _xPadding, (value) => $$invalidate(18, $_xPadding = value));
  const _yPadding = writable(yPadding);
  validate_store(_yPadding, "_yPadding");
  component_subscribe($$self, _yPadding, (value) => $$invalidate(17, $_yPadding = value));
  const _zPadding = writable(zPadding);
  validate_store(_zPadding, "_zPadding");
  component_subscribe($$self, _zPadding, (value) => $$invalidate(16, $_zPadding = value));
  const _rPadding = writable(rPadding);
  validate_store(_rPadding, "_rPadding");
  component_subscribe($$self, _rPadding, (value) => $$invalidate(15, $_rPadding = value));
  const _xRange = writable(xRange);
  validate_store(_xRange, "_xRange");
  component_subscribe($$self, _xRange, (value) => $$invalidate(180, $_xRange = value));
  const _yRange = writable(yRange);
  validate_store(_yRange, "_yRange");
  component_subscribe($$self, _yRange, (value) => $$invalidate(179, $_yRange = value));
  const _zRange = writable(zRange);
  validate_store(_zRange, "_zRange");
  component_subscribe($$self, _zRange, (value) => $$invalidate(178, $_zRange = value));
  const _rRange = writable(rRange);
  validate_store(_rRange, "_rRange");
  component_subscribe($$self, _rRange, (value) => $$invalidate(177, $_rRange = value));
  const _xScale = writable(xScale);
  validate_store(_xScale, "_xScale");
  component_subscribe($$self, _xScale, (value) => $$invalidate(176, $_xScale = value));
  const _yScale = writable(yScale);
  validate_store(_yScale, "_yScale");
  component_subscribe($$self, _yScale, (value) => $$invalidate(175, $_yScale = value));
  const _zScale = writable(zScale);
  validate_store(_zScale, "_zScale");
  component_subscribe($$self, _zScale, (value) => $$invalidate(174, $_zScale = value));
  const _rScale = writable(rScale);
  validate_store(_rScale, "_rScale");
  component_subscribe($$self, _rScale, (value) => $$invalidate(173, $_rScale = value));
  const _xDomainSort = writable(xDomainSort);
  validate_store(_xDomainSort, "_xDomainSort");
  component_subscribe($$self, _xDomainSort, (value) => $$invalidate(37, $_xDomainSort = value));
  const _yDomainSort = writable(yDomainSort);
  validate_store(_yDomainSort, "_yDomainSort");
  component_subscribe($$self, _yDomainSort, (value) => $$invalidate(38, $_yDomainSort = value));
  const _zDomainSort = writable(zDomainSort);
  validate_store(_zDomainSort, "_zDomainSort");
  component_subscribe($$self, _zDomainSort, (value) => $$invalidate(39, $_zDomainSort = value));
  const _rDomainSort = writable(rDomainSort);
  validate_store(_rDomainSort, "_rDomainSort");
  component_subscribe($$self, _rDomainSort, (value) => $$invalidate(40, $_rDomainSort = value));
  const _config = writable(config);
  validate_store(_config, "_config");
  component_subscribe($$self, _config, (value) => $$invalidate(13, $_config = value));
  const _custom = writable(custom);
  validate_store(_custom, "_custom");
  component_subscribe($$self, _custom, (value) => $$invalidate(14, $_custom = value));
  const _deriveScales = writable(deriveScales);
  validate_store(_deriveScales, "_deriveScales");
  component_subscribe($$self, _deriveScales, (value) => $$invalidate(167, $_deriveScales = value));
  const activeGetters_d = derived([_x, _y, _z, _r], ([$x, $y, $z, $r]) => {
    const obj = {};
    if ($x) {
      obj.x = $x;
    }
    if ($y) {
      obj.y = $y;
    }
    if ($z) {
      obj.z = $z;
    }
    if ($r) {
      obj.r = $r;
    }
    return obj;
  });
  validate_store(activeGetters_d, "activeGetters_d");
  component_subscribe($$self, activeGetters_d, (value) => $$invalidate(10, $activeGetters_d = value));
  const padding_d = derived([_padding, _containerWidth, _containerHeight], ([$padding]) => {
    const defaultPadding = { top: 0, right: 0, bottom: 0, left: 0 };
    return Object.assign(defaultPadding, $padding);
  });
  validate_store(padding_d, "padding_d");
  component_subscribe($$self, padding_d, (value) => $$invalidate(41, $padding_d = value));
  const box_d = derived([_containerWidth, _containerHeight, padding_d], ([$containerWidth, $containerHeight, $padding]) => {
    const b = {};
    b.top = $padding.top;
    b.right = $containerWidth - $padding.right;
    b.bottom = $containerHeight - $padding.bottom;
    b.left = $padding.left;
    b.width = b.right - b.left;
    b.height = b.bottom - b.top;
    if (verbose === true) {
      if (b.width <= 0 && isMounted === true) {
        console.warn("[LayerCake] Target div has zero or negative width. Did you forget to set an explicit width in CSS on the container?");
      }
      if (b.height <= 0 && isMounted === true) {
        console.warn("[LayerCake] Target div has zero or negative height. Did you forget to set an explicit height in CSS on the container?");
      }
    }
    return b;
  });
  validate_store(box_d, "box_d");
  component_subscribe($$self, box_d, (value) => $$invalidate(166, $box_d = value));
  const width_d = derived([box_d], ([$box]) => {
    return $box.width;
  });
  validate_store(width_d, "width_d");
  component_subscribe($$self, width_d, (value) => $$invalidate(34, $width_d = value));
  const height_d = derived([box_d], ([$box]) => {
    return $box.height;
  });
  validate_store(height_d, "height_d");
  component_subscribe($$self, height_d, (value) => $$invalidate(35, $height_d = value));
  const extents_d = derived(
    [
      _flatData,
      activeGetters_d,
      _extents,
      _xScale,
      _yScale,
      _rScale,
      _zScale,
      _xDomainSort,
      _yDomainSort,
      _zDomainSort,
      _rDomainSort
    ],
    ([
      $flatData,
      $activeGetters,
      $extents,
      $_xScale2,
      $_yScale2,
      $_rScale2,
      $_zScale2,
      $_xDomainSort2,
      $_yDomainSort2,
      $_zDomainSort2,
      $_rDomainSort2
    ]) => {
      const scaleLookup = {
        x: { scale: $_xScale2, sort: $_xDomainSort2 },
        y: { scale: $_yScale2, sort: $_yDomainSort2 },
        r: { scale: $_rScale2, sort: $_rDomainSort2 },
        z: { scale: $_zScale2, sort: $_zDomainSort2 }
      };
      const getters = filterObject($activeGetters, $extents);
      const activeScales = Object.fromEntries(Object.keys(getters).map((k) => [k, scaleLookup[k]]));
      if (Object.keys(getters).length > 0) {
        const calculatedExtents = calcScaleExtents($flatData, getters, activeScales);
        return { ...calculatedExtents, ...$extents };
      } else {
        return {};
      }
    }
  );
  validate_store(extents_d, "extents_d");
  component_subscribe($$self, extents_d, (value) => $$invalidate(42, $extents_d = value));
  const xDomain_d = derived([extents_d, _xDomain], calcDomain("x"));
  validate_store(xDomain_d, "xDomain_d");
  component_subscribe($$self, xDomain_d, (value) => $$invalidate(43, $xDomain_d = value));
  const yDomain_d = derived([extents_d, _yDomain], calcDomain("y"));
  validate_store(yDomain_d, "yDomain_d");
  component_subscribe($$self, yDomain_d, (value) => $$invalidate(44, $yDomain_d = value));
  const zDomain_d = derived([extents_d, _zDomain], calcDomain("z"));
  validate_store(zDomain_d, "zDomain_d");
  component_subscribe($$self, zDomain_d, (value) => $$invalidate(45, $zDomain_d = value));
  const rDomain_d = derived([extents_d, _rDomain], calcDomain("r"));
  validate_store(rDomain_d, "rDomain_d");
  component_subscribe($$self, rDomain_d, (value) => $$invalidate(46, $rDomain_d = value));
  const xScale_d = derived(
    [
      _xScale,
      extents_d,
      xDomain_d,
      _xPadding,
      _xNice,
      _xReverse,
      width_d,
      height_d,
      _xRange,
      _percentRange
    ],
    createScale("x")
  );
  validate_store(xScale_d, "xScale_d");
  component_subscribe($$self, xScale_d, (value) => $$invalidate(9, $xScale_d = value));
  const xGet_d = derived([_x, xScale_d], createGetter);
  validate_store(xGet_d, "xGet_d");
  component_subscribe($$self, xGet_d, (value) => $$invalidate(51, $xGet_d = value));
  const yScale_d = derived(
    [
      _yScale,
      extents_d,
      yDomain_d,
      _yPadding,
      _yNice,
      _yReverse,
      width_d,
      height_d,
      _yRange,
      _percentRange
    ],
    createScale("y")
  );
  validate_store(yScale_d, "yScale_d");
  component_subscribe($$self, yScale_d, (value) => $$invalidate(8, $yScale_d = value));
  const yGet_d = derived([_y, yScale_d], createGetter);
  validate_store(yGet_d, "yGet_d");
  component_subscribe($$self, yGet_d, (value) => $$invalidate(52, $yGet_d = value));
  const zScale_d = derived(
    [
      _zScale,
      extents_d,
      zDomain_d,
      _zPadding,
      _zNice,
      _zReverse,
      width_d,
      height_d,
      _zRange,
      _percentRange
    ],
    createScale("z")
  );
  validate_store(zScale_d, "zScale_d");
  component_subscribe($$self, zScale_d, (value) => $$invalidate(7, $zScale_d = value));
  const zGet_d = derived([_z, zScale_d], createGetter);
  validate_store(zGet_d, "zGet_d");
  component_subscribe($$self, zGet_d, (value) => $$invalidate(53, $zGet_d = value));
  const rScale_d = derived(
    [
      _rScale,
      extents_d,
      rDomain_d,
      _rPadding,
      _rNice,
      _rReverse,
      width_d,
      height_d,
      _rRange,
      _percentRange
    ],
    createScale("r")
  );
  validate_store(rScale_d, "rScale_d");
  component_subscribe($$self, rScale_d, (value) => $$invalidate(6, $rScale_d = value));
  const rGet_d = derived([_r, rScale_d], createGetter);
  validate_store(rGet_d, "rGet_d");
  component_subscribe($$self, rGet_d, (value) => $$invalidate(54, $rGet_d = value));
  const xDomain_d_possibly_nice = derived(xScale_d, ($xScale_d2) => $xScale_d2.domain());
  const yDomain_d_possibly_nice = derived(yScale_d, ($yScale_d2) => $yScale_d2.domain());
  const zDomain_d_possibly_nice = derived(zScale_d, ($zScale_d2) => $zScale_d2.domain());
  const rDomain_d_possibly_nice = derived(rScale_d, ($rScale_d2) => $rScale_d2.domain());
  const xRange_d = derived([xScale_d], getRange);
  validate_store(xRange_d, "xRange_d");
  component_subscribe($$self, xRange_d, (value) => $$invalidate(47, $xRange_d = value));
  const yRange_d = derived([yScale_d], getRange);
  validate_store(yRange_d, "yRange_d");
  component_subscribe($$self, yRange_d, (value) => $$invalidate(48, $yRange_d = value));
  const zRange_d = derived([zScale_d], getRange);
  validate_store(zRange_d, "zRange_d");
  component_subscribe($$self, zRange_d, (value) => $$invalidate(49, $zRange_d = value));
  const rRange_d = derived([rScale_d], getRange);
  validate_store(rRange_d, "rRange_d");
  component_subscribe($$self, rRange_d, (value) => $$invalidate(50, $rRange_d = value));
  const aspectRatio_d = derived([width_d, height_d], ([$width, $height]) => {
    return $width / $height;
  });
  validate_store(aspectRatio_d, "aspectRatio_d");
  component_subscribe($$self, aspectRatio_d, (value) => $$invalidate(36, $aspectRatio_d = value));
  const derivedScales = Object.fromEntries(Object.entries($_deriveScales).map(([name, fn]) => {
    return [
      name,
      writable(fn({
        xScale: $xScale_d.copy(),
        yScale: $yScale_d.copy(),
        zScale: $zScale_d.copy(),
        rScale: $rScale_d.copy()
      }))
    ];
  }));
  const writable_props = [
    "ssr",
    "pointerEvents",
    "position",
    "percentRange",
    "width",
    "height",
    "containerWidth",
    "containerHeight",
    "element",
    "x",
    "y",
    "z",
    "r",
    "data",
    "xDomain",
    "yDomain",
    "zDomain",
    "rDomain",
    "xNice",
    "yNice",
    "zNice",
    "rNice",
    "xPadding",
    "yPadding",
    "zPadding",
    "rPadding",
    "xScale",
    "yScale",
    "zScale",
    "rScale",
    "xRange",
    "yRange",
    "zRange",
    "rRange",
    "xReverse",
    "yReverse",
    "zReverse",
    "rReverse",
    "xDomainSort",
    "yDomainSort",
    "zDomainSort",
    "rDomainSort",
    "padding",
    "extents",
    "deriveScales",
    "flatData",
    "custom",
    "debug",
    "verbose"
  ];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<LayerCake> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  function div_elementresize_handler() {
    containerWidth = this.clientWidth;
    containerHeight = this.clientHeight;
    $$invalidate(0, containerWidth);
    $$invalidate(1, containerHeight);
  }
  $$self.$$set = ($$props2) => {
    if ("ssr" in $$props2)
      $$invalidate(3, ssr = $$props2.ssr);
    if ("pointerEvents" in $$props2)
      $$invalidate(4, pointerEvents = $$props2.pointerEvents);
    if ("position" in $$props2)
      $$invalidate(5, position = $$props2.position);
    if ("percentRange" in $$props2)
      $$invalidate(120, percentRange = $$props2.percentRange);
    if ("width" in $$props2)
      $$invalidate(121, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(122, height = $$props2.height);
    if ("containerWidth" in $$props2)
      $$invalidate(0, containerWidth = $$props2.containerWidth);
    if ("containerHeight" in $$props2)
      $$invalidate(1, containerHeight = $$props2.containerHeight);
    if ("element" in $$props2)
      $$invalidate(2, element2 = $$props2.element);
    if ("x" in $$props2)
      $$invalidate(123, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(124, y = $$props2.y);
    if ("z" in $$props2)
      $$invalidate(125, z = $$props2.z);
    if ("r" in $$props2)
      $$invalidate(126, r = $$props2.r);
    if ("data" in $$props2)
      $$invalidate(127, data = $$props2.data);
    if ("xDomain" in $$props2)
      $$invalidate(128, xDomain = $$props2.xDomain);
    if ("yDomain" in $$props2)
      $$invalidate(129, yDomain = $$props2.yDomain);
    if ("zDomain" in $$props2)
      $$invalidate(130, zDomain = $$props2.zDomain);
    if ("rDomain" in $$props2)
      $$invalidate(131, rDomain = $$props2.rDomain);
    if ("xNice" in $$props2)
      $$invalidate(132, xNice = $$props2.xNice);
    if ("yNice" in $$props2)
      $$invalidate(133, yNice = $$props2.yNice);
    if ("zNice" in $$props2)
      $$invalidate(134, zNice = $$props2.zNice);
    if ("rNice" in $$props2)
      $$invalidate(135, rNice = $$props2.rNice);
    if ("xPadding" in $$props2)
      $$invalidate(136, xPadding = $$props2.xPadding);
    if ("yPadding" in $$props2)
      $$invalidate(137, yPadding = $$props2.yPadding);
    if ("zPadding" in $$props2)
      $$invalidate(138, zPadding = $$props2.zPadding);
    if ("rPadding" in $$props2)
      $$invalidate(139, rPadding = $$props2.rPadding);
    if ("xScale" in $$props2)
      $$invalidate(140, xScale = $$props2.xScale);
    if ("yScale" in $$props2)
      $$invalidate(141, yScale = $$props2.yScale);
    if ("zScale" in $$props2)
      $$invalidate(142, zScale = $$props2.zScale);
    if ("rScale" in $$props2)
      $$invalidate(143, rScale = $$props2.rScale);
    if ("xRange" in $$props2)
      $$invalidate(144, xRange = $$props2.xRange);
    if ("yRange" in $$props2)
      $$invalidate(145, yRange = $$props2.yRange);
    if ("zRange" in $$props2)
      $$invalidate(146, zRange = $$props2.zRange);
    if ("rRange" in $$props2)
      $$invalidate(147, rRange = $$props2.rRange);
    if ("xReverse" in $$props2)
      $$invalidate(148, xReverse = $$props2.xReverse);
    if ("yReverse" in $$props2)
      $$invalidate(149, yReverse = $$props2.yReverse);
    if ("zReverse" in $$props2)
      $$invalidate(150, zReverse = $$props2.zReverse);
    if ("rReverse" in $$props2)
      $$invalidate(151, rReverse = $$props2.rReverse);
    if ("xDomainSort" in $$props2)
      $$invalidate(152, xDomainSort = $$props2.xDomainSort);
    if ("yDomainSort" in $$props2)
      $$invalidate(153, yDomainSort = $$props2.yDomainSort);
    if ("zDomainSort" in $$props2)
      $$invalidate(154, zDomainSort = $$props2.zDomainSort);
    if ("rDomainSort" in $$props2)
      $$invalidate(155, rDomainSort = $$props2.rDomainSort);
    if ("padding" in $$props2)
      $$invalidate(156, padding = $$props2.padding);
    if ("extents" in $$props2)
      $$invalidate(157, extents = $$props2.extents);
    if ("deriveScales" in $$props2)
      $$invalidate(158, deriveScales = $$props2.deriveScales);
    if ("flatData" in $$props2)
      $$invalidate(159, flatData = $$props2.flatData);
    if ("custom" in $$props2)
      $$invalidate(160, custom = $$props2.custom);
    if ("debug" in $$props2)
      $$invalidate(161, debug = $$props2.debug);
    if ("verbose" in $$props2)
      $$invalidate(162, verbose = $$props2.verbose);
    if ("$$scope" in $$props2)
      $$invalidate(168, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    onMount,
    writable,
    derived,
    makeAccessor,
    filterObject,
    debounce,
    calcScaleExtents,
    calcDomain,
    createScale,
    createGetter,
    getRange,
    printDebug,
    defaultScales: defaultScales_default,
    printDebug_debounced,
    ssr,
    pointerEvents,
    position,
    percentRange,
    width,
    height,
    containerWidth,
    containerHeight,
    element: element2,
    x,
    y,
    z,
    r,
    data,
    xDomain,
    yDomain,
    zDomain,
    rDomain,
    xNice,
    yNice,
    zNice,
    rNice,
    xPadding,
    yPadding,
    zPadding,
    rPadding,
    xScale,
    yScale,
    zScale,
    rScale,
    xRange,
    yRange,
    zRange,
    rRange,
    xReverse,
    yReverse,
    zReverse,
    rReverse,
    xDomainSort,
    yDomainSort,
    zDomainSort,
    rDomainSort,
    padding,
    extents,
    deriveScales,
    flatData,
    custom,
    debug,
    verbose,
    isMounted,
    config,
    _percentRange,
    _containerWidth,
    _containerHeight,
    _extents,
    _data,
    _flatData,
    _padding,
    _x,
    _y,
    _z,
    _r,
    _xDomain,
    _yDomain,
    _zDomain,
    _rDomain,
    _xNice,
    _yNice,
    _zNice,
    _rNice,
    _xReverse,
    _yReverse,
    _zReverse,
    _rReverse,
    _xPadding,
    _yPadding,
    _zPadding,
    _rPadding,
    _xRange,
    _yRange,
    _zRange,
    _rRange,
    _xScale,
    _yScale,
    _zScale,
    _rScale,
    _xDomainSort,
    _yDomainSort,
    _zDomainSort,
    _rDomainSort,
    _config,
    _custom,
    _deriveScales,
    activeGetters_d,
    padding_d,
    box_d,
    width_d,
    height_d,
    extents_d,
    xDomain_d,
    yDomain_d,
    zDomain_d,
    rDomain_d,
    xScale_d,
    xGet_d,
    yScale_d,
    yGet_d,
    zScale_d,
    zGet_d,
    rScale_d,
    rGet_d,
    xDomain_d_possibly_nice,
    yDomain_d_possibly_nice,
    zDomain_d_possibly_nice,
    rDomain_d_possibly_nice,
    xRange_d,
    yRange_d,
    zRange_d,
    rRange_d,
    aspectRatio_d,
    derivedScales,
    context,
    yReverseValue,
    $rScale_d,
    $zScale_d,
    $yScale_d,
    $xScale_d,
    $activeGetters_d,
    $box_d,
    $_flatData,
    $_data,
    $_deriveScales,
    $_config,
    $_custom,
    $_rScale,
    $_zScale,
    $_yScale,
    $_xScale,
    $_rRange,
    $_zRange,
    $_yRange,
    $_xRange,
    $_rPadding,
    $_zPadding,
    $_yPadding,
    $_xPadding,
    $_rReverse,
    $_zReverse,
    $_yReverse,
    $_xReverse,
    $_rNice,
    $_zNice,
    $_yNice,
    $_xNice,
    $_rDomain,
    $_zDomain,
    $_yDomain,
    $_xDomain,
    $_r,
    $_z,
    $_y,
    $_x,
    $_padding,
    $_extents,
    $_containerHeight,
    $_containerWidth,
    $_percentRange,
    $width_d,
    $height_d,
    $aspectRatio_d,
    $_xDomainSort,
    $_yDomainSort,
    $_zDomainSort,
    $_rDomainSort,
    $padding_d,
    $extents_d,
    $xDomain_d,
    $yDomain_d,
    $zDomain_d,
    $rDomain_d,
    $xRange_d,
    $yRange_d,
    $zRange_d,
    $rRange_d,
    $xGet_d,
    $yGet_d,
    $zGet_d,
    $rGet_d
  });
  $$self.$inject_state = ($$props2) => {
    if ("ssr" in $$props2)
      $$invalidate(3, ssr = $$props2.ssr);
    if ("pointerEvents" in $$props2)
      $$invalidate(4, pointerEvents = $$props2.pointerEvents);
    if ("position" in $$props2)
      $$invalidate(5, position = $$props2.position);
    if ("percentRange" in $$props2)
      $$invalidate(120, percentRange = $$props2.percentRange);
    if ("width" in $$props2)
      $$invalidate(121, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(122, height = $$props2.height);
    if ("containerWidth" in $$props2)
      $$invalidate(0, containerWidth = $$props2.containerWidth);
    if ("containerHeight" in $$props2)
      $$invalidate(1, containerHeight = $$props2.containerHeight);
    if ("element" in $$props2)
      $$invalidate(2, element2 = $$props2.element);
    if ("x" in $$props2)
      $$invalidate(123, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(124, y = $$props2.y);
    if ("z" in $$props2)
      $$invalidate(125, z = $$props2.z);
    if ("r" in $$props2)
      $$invalidate(126, r = $$props2.r);
    if ("data" in $$props2)
      $$invalidate(127, data = $$props2.data);
    if ("xDomain" in $$props2)
      $$invalidate(128, xDomain = $$props2.xDomain);
    if ("yDomain" in $$props2)
      $$invalidate(129, yDomain = $$props2.yDomain);
    if ("zDomain" in $$props2)
      $$invalidate(130, zDomain = $$props2.zDomain);
    if ("rDomain" in $$props2)
      $$invalidate(131, rDomain = $$props2.rDomain);
    if ("xNice" in $$props2)
      $$invalidate(132, xNice = $$props2.xNice);
    if ("yNice" in $$props2)
      $$invalidate(133, yNice = $$props2.yNice);
    if ("zNice" in $$props2)
      $$invalidate(134, zNice = $$props2.zNice);
    if ("rNice" in $$props2)
      $$invalidate(135, rNice = $$props2.rNice);
    if ("xPadding" in $$props2)
      $$invalidate(136, xPadding = $$props2.xPadding);
    if ("yPadding" in $$props2)
      $$invalidate(137, yPadding = $$props2.yPadding);
    if ("zPadding" in $$props2)
      $$invalidate(138, zPadding = $$props2.zPadding);
    if ("rPadding" in $$props2)
      $$invalidate(139, rPadding = $$props2.rPadding);
    if ("xScale" in $$props2)
      $$invalidate(140, xScale = $$props2.xScale);
    if ("yScale" in $$props2)
      $$invalidate(141, yScale = $$props2.yScale);
    if ("zScale" in $$props2)
      $$invalidate(142, zScale = $$props2.zScale);
    if ("rScale" in $$props2)
      $$invalidate(143, rScale = $$props2.rScale);
    if ("xRange" in $$props2)
      $$invalidate(144, xRange = $$props2.xRange);
    if ("yRange" in $$props2)
      $$invalidate(145, yRange = $$props2.yRange);
    if ("zRange" in $$props2)
      $$invalidate(146, zRange = $$props2.zRange);
    if ("rRange" in $$props2)
      $$invalidate(147, rRange = $$props2.rRange);
    if ("xReverse" in $$props2)
      $$invalidate(148, xReverse = $$props2.xReverse);
    if ("yReverse" in $$props2)
      $$invalidate(149, yReverse = $$props2.yReverse);
    if ("zReverse" in $$props2)
      $$invalidate(150, zReverse = $$props2.zReverse);
    if ("rReverse" in $$props2)
      $$invalidate(151, rReverse = $$props2.rReverse);
    if ("xDomainSort" in $$props2)
      $$invalidate(152, xDomainSort = $$props2.xDomainSort);
    if ("yDomainSort" in $$props2)
      $$invalidate(153, yDomainSort = $$props2.yDomainSort);
    if ("zDomainSort" in $$props2)
      $$invalidate(154, zDomainSort = $$props2.zDomainSort);
    if ("rDomainSort" in $$props2)
      $$invalidate(155, rDomainSort = $$props2.rDomainSort);
    if ("padding" in $$props2)
      $$invalidate(156, padding = $$props2.padding);
    if ("extents" in $$props2)
      $$invalidate(157, extents = $$props2.extents);
    if ("deriveScales" in $$props2)
      $$invalidate(158, deriveScales = $$props2.deriveScales);
    if ("flatData" in $$props2)
      $$invalidate(159, flatData = $$props2.flatData);
    if ("custom" in $$props2)
      $$invalidate(160, custom = $$props2.custom);
    if ("debug" in $$props2)
      $$invalidate(161, debug = $$props2.debug);
    if ("verbose" in $$props2)
      $$invalidate(162, verbose = $$props2.verbose);
    if ("isMounted" in $$props2)
      isMounted = $$props2.isMounted;
    if ("context" in $$props2)
      $$invalidate(164, context = $$props2.context);
    if ("yReverseValue" in $$props2)
      $$invalidate(165, yReverseValue = $$props2.yReverseValue);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[4] & /*yReverse, yScale*/
    33685504) {
      $:
        $$invalidate(165, yReverseValue = typeof yReverse === "undefined" ? typeof yScale.bandwidth === "function" ? false : true : yReverse);
    }
    if ($$self.$$.dirty[3] & /*x*/
    1073741824) {
      $:
        if (x)
          $$invalidate(163, config.x = x, config);
    }
    if ($$self.$$.dirty[4] & /*y*/
    1) {
      $:
        if (y)
          $$invalidate(163, config.y = y, config);
    }
    if ($$self.$$.dirty[4] & /*z*/
    2) {
      $:
        if (z)
          $$invalidate(163, config.z = z, config);
    }
    if ($$self.$$.dirty[4] & /*r*/
    4) {
      $:
        if (r)
          $$invalidate(163, config.r = r, config);
    }
    if ($$self.$$.dirty[4] & /*xDomain*/
    16) {
      $:
        if (xDomain)
          $$invalidate(163, config.xDomain = xDomain, config);
    }
    if ($$self.$$.dirty[4] & /*yDomain*/
    32) {
      $:
        if (yDomain)
          $$invalidate(163, config.yDomain = yDomain, config);
    }
    if ($$self.$$.dirty[4] & /*zDomain*/
    64) {
      $:
        if (zDomain)
          $$invalidate(163, config.zDomain = zDomain, config);
    }
    if ($$self.$$.dirty[4] & /*rDomain*/
    128) {
      $:
        if (rDomain)
          $$invalidate(163, config.rDomain = rDomain, config);
    }
    if ($$self.$$.dirty[4] & /*xRange*/
    1048576) {
      $:
        if (xRange)
          $$invalidate(163, config.xRange = xRange, config);
    }
    if ($$self.$$.dirty[4] & /*yRange*/
    2097152) {
      $:
        if (yRange)
          $$invalidate(163, config.yRange = yRange, config);
    }
    if ($$self.$$.dirty[4] & /*zRange*/
    4194304) {
      $:
        if (zRange)
          $$invalidate(163, config.zRange = zRange, config);
    }
    if ($$self.$$.dirty[4] & /*rRange*/
    8388608) {
      $:
        if (rRange)
          $$invalidate(163, config.rRange = rRange, config);
    }
    if ($$self.$$.dirty[3] & /*percentRange*/
    134217728) {
      $:
        set_store_value(_percentRange, $_percentRange = percentRange, $_percentRange);
    }
    if ($$self.$$.dirty[0] & /*containerWidth*/
    1) {
      $:
        set_store_value(_containerWidth, $_containerWidth = containerWidth, $_containerWidth);
    }
    if ($$self.$$.dirty[0] & /*containerHeight*/
    2) {
      $:
        set_store_value(_containerHeight, $_containerHeight = containerHeight, $_containerHeight);
    }
    if ($$self.$$.dirty[5] & /*extents*/
    4) {
      $:
        set_store_value(_extents, $_extents = filterObject(extents), $_extents);
    }
    if ($$self.$$.dirty[4] & /*data*/
    8) {
      $:
        set_store_value(_data, $_data = data, $_data);
    }
    if ($$self.$$.dirty[4] & /*data*/
    8 | $$self.$$.dirty[5] & /*flatData*/
    16) {
      $:
        set_store_value(_flatData, $_flatData = flatData || data, $_flatData);
    }
    if ($$self.$$.dirty[5] & /*padding*/
    2) {
      $:
        set_store_value(_padding, $_padding = padding, $_padding);
    }
    if ($$self.$$.dirty[3] & /*x*/
    1073741824) {
      $:
        set_store_value(_x, $_x = makeAccessor(x), $_x);
    }
    if ($$self.$$.dirty[4] & /*y*/
    1) {
      $:
        set_store_value(_y, $_y = makeAccessor(y), $_y);
    }
    if ($$self.$$.dirty[4] & /*z*/
    2) {
      $:
        set_store_value(_z, $_z = makeAccessor(z), $_z);
    }
    if ($$self.$$.dirty[4] & /*r*/
    4) {
      $:
        set_store_value(_r, $_r = makeAccessor(r), $_r);
    }
    if ($$self.$$.dirty[4] & /*xDomain*/
    16) {
      $:
        set_store_value(_xDomain, $_xDomain = xDomain, $_xDomain);
    }
    if ($$self.$$.dirty[4] & /*yDomain*/
    32) {
      $:
        set_store_value(_yDomain, $_yDomain = yDomain, $_yDomain);
    }
    if ($$self.$$.dirty[4] & /*zDomain*/
    64) {
      $:
        set_store_value(_zDomain, $_zDomain = zDomain, $_zDomain);
    }
    if ($$self.$$.dirty[4] & /*rDomain*/
    128) {
      $:
        set_store_value(_rDomain, $_rDomain = rDomain, $_rDomain);
    }
    if ($$self.$$.dirty[4] & /*xNice*/
    256) {
      $:
        set_store_value(_xNice, $_xNice = xNice, $_xNice);
    }
    if ($$self.$$.dirty[4] & /*yNice*/
    512) {
      $:
        set_store_value(_yNice, $_yNice = yNice, $_yNice);
    }
    if ($$self.$$.dirty[4] & /*zNice*/
    1024) {
      $:
        set_store_value(_zNice, $_zNice = zNice, $_zNice);
    }
    if ($$self.$$.dirty[4] & /*rNice*/
    2048) {
      $:
        set_store_value(_rNice, $_rNice = rNice, $_rNice);
    }
    if ($$self.$$.dirty[4] & /*xReverse*/
    16777216) {
      $:
        set_store_value(_xReverse, $_xReverse = xReverse, $_xReverse);
    }
    if ($$self.$$.dirty[5] & /*yReverseValue*/
    1024) {
      $:
        set_store_value(_yReverse, $_yReverse = yReverseValue, $_yReverse);
    }
    if ($$self.$$.dirty[4] & /*zReverse*/
    67108864) {
      $:
        set_store_value(_zReverse, $_zReverse = zReverse, $_zReverse);
    }
    if ($$self.$$.dirty[4] & /*rReverse*/
    134217728) {
      $:
        set_store_value(_rReverse, $_rReverse = rReverse, $_rReverse);
    }
    if ($$self.$$.dirty[4] & /*xPadding*/
    4096) {
      $:
        set_store_value(_xPadding, $_xPadding = xPadding, $_xPadding);
    }
    if ($$self.$$.dirty[4] & /*yPadding*/
    8192) {
      $:
        set_store_value(_yPadding, $_yPadding = yPadding, $_yPadding);
    }
    if ($$self.$$.dirty[4] & /*zPadding*/
    16384) {
      $:
        set_store_value(_zPadding, $_zPadding = zPadding, $_zPadding);
    }
    if ($$self.$$.dirty[4] & /*rPadding*/
    32768) {
      $:
        set_store_value(_rPadding, $_rPadding = rPadding, $_rPadding);
    }
    if ($$self.$$.dirty[4] & /*xRange*/
    1048576) {
      $:
        set_store_value(_xRange, $_xRange = xRange, $_xRange);
    }
    if ($$self.$$.dirty[4] & /*yRange*/
    2097152) {
      $:
        set_store_value(_yRange, $_yRange = yRange, $_yRange);
    }
    if ($$self.$$.dirty[4] & /*zRange*/
    4194304) {
      $:
        set_store_value(_zRange, $_zRange = zRange, $_zRange);
    }
    if ($$self.$$.dirty[4] & /*rRange*/
    8388608) {
      $:
        set_store_value(_rRange, $_rRange = rRange, $_rRange);
    }
    if ($$self.$$.dirty[4] & /*xScale*/
    65536) {
      $:
        set_store_value(_xScale, $_xScale = xScale, $_xScale);
    }
    if ($$self.$$.dirty[4] & /*yScale*/
    131072) {
      $:
        set_store_value(_yScale, $_yScale = yScale, $_yScale);
    }
    if ($$self.$$.dirty[4] & /*zScale*/
    262144) {
      $:
        set_store_value(_zScale, $_zScale = zScale, $_zScale);
    }
    if ($$self.$$.dirty[4] & /*rScale*/
    524288) {
      $:
        set_store_value(_rScale, $_rScale = rScale, $_rScale);
    }
    if ($$self.$$.dirty[5] & /*custom*/
    32) {
      $:
        set_store_value(_custom, $_custom = custom, $_custom);
    }
    if ($$self.$$.dirty[5] & /*config*/
    256) {
      $:
        set_store_value(_config, $_config = config, $_config);
    }
    if ($$self.$$.dirty[5] & /*deriveScales*/
    8) {
      $:
        set_store_value(_deriveScales, $_deriveScales = deriveScales, $_deriveScales);
    }
    if ($$self.$$.dirty[0] & /*$xScale_d, $yScale_d, $zScale_d, $rScale_d*/
    960 | $$self.$$.dirty[5] & /*$_deriveScales*/
    4096) {
      $:
        if ($_deriveScales) {
          for (const [name, fn] of Object.entries($_deriveScales)) {
            derivedScales[name].set(fn({
              xScale: $xScale_d.copy(),
              yScale: $yScale_d.copy(),
              zScale: $zScale_d.copy(),
              rScale: $rScale_d.copy()
            }));
          }
        }
    }
    if ($$self.$$.dirty[5] & /*context*/
    512) {
      $:
        setContext("LayerCake", context);
    }
    if ($$self.$$.dirty[0] & /*ssr, $_data, $_flatData, $activeGetters_d, $xScale_d, $yScale_d, $zScale_d, $rScale_d*/
    8136 | $$self.$$.dirty[5] & /*$box_d, debug, flatData, config*/
    2384) {
      $:
        if ($box_d && debug === true && (ssr === true || typeof window !== "undefined")) {
          printDebug_debounced({
            data: $_data,
            flatData: typeof flatData !== "undefined" ? $_flatData : null,
            boundingBox: $box_d,
            activeGetters: $activeGetters_d,
            x: config.x,
            y: config.y,
            z: config.z,
            r: config.r,
            xScale: $xScale_d,
            yScale: $yScale_d,
            zScale: $zScale_d,
            rScale: $rScale_d
          });
        }
    }
  };
  $:
    $$invalidate(164, context = {
      ...derivedScales,
      activeGetters: activeGetters_d,
      width: width_d,
      height: height_d,
      percentRange: _percentRange,
      aspectRatio: aspectRatio_d,
      containerWidth: _containerWidth,
      containerHeight: _containerHeight,
      x: _x,
      y: _y,
      z: _z,
      r: _r,
      custom: _custom,
      data: _data,
      xNice: _xNice,
      yNice: _yNice,
      zNice: _zNice,
      rNice: _rNice,
      xDomainSort: _xDomainSort,
      yDomainSort: _yDomainSort,
      zDomainSort: _zDomainSort,
      rDomainSort: _rDomainSort,
      xReverse: _xReverse,
      yReverse: _yReverse,
      zReverse: _zReverse,
      rReverse: _rReverse,
      xPadding: _xPadding,
      yPadding: _yPadding,
      zPadding: _zPadding,
      rPadding: _rPadding,
      padding: padding_d,
      flatData: _flatData,
      extents: extents_d,
      xDomain: xDomain_d_possibly_nice,
      yDomain: yDomain_d_possibly_nice,
      zDomain: zDomain_d_possibly_nice,
      rDomain: rDomain_d_possibly_nice,
      xRange: xRange_d,
      yRange: yRange_d,
      zRange: zRange_d,
      rRange: rRange_d,
      config: _config,
      xScale: xScale_d,
      xGet: xGet_d,
      yScale: yScale_d,
      yGet: yGet_d,
      zScale: zScale_d,
      zGet: zGet_d,
      rScale: rScale_d,
      rGet: rGet_d
    });
  return [
    containerWidth,
    containerHeight,
    element2,
    ssr,
    pointerEvents,
    position,
    $rScale_d,
    $zScale_d,
    $yScale_d,
    $xScale_d,
    $activeGetters_d,
    $_flatData,
    $_data,
    $_config,
    $_custom,
    $_rPadding,
    $_zPadding,
    $_yPadding,
    $_xPadding,
    $_rReverse,
    $_zReverse,
    $_yReverse,
    $_xReverse,
    $_rNice,
    $_zNice,
    $_yNice,
    $_xNice,
    $_r,
    $_z,
    $_y,
    $_x,
    $_containerHeight,
    $_containerWidth,
    $_percentRange,
    $width_d,
    $height_d,
    $aspectRatio_d,
    $_xDomainSort,
    $_yDomainSort,
    $_zDomainSort,
    $_rDomainSort,
    $padding_d,
    $extents_d,
    $xDomain_d,
    $yDomain_d,
    $zDomain_d,
    $rDomain_d,
    $xRange_d,
    $yRange_d,
    $zRange_d,
    $rRange_d,
    $xGet_d,
    $yGet_d,
    $zGet_d,
    $rGet_d,
    _percentRange,
    _containerWidth,
    _containerHeight,
    _extents,
    _data,
    _flatData,
    _padding,
    _x,
    _y,
    _z,
    _r,
    _xDomain,
    _yDomain,
    _zDomain,
    _rDomain,
    _xNice,
    _yNice,
    _zNice,
    _rNice,
    _xReverse,
    _yReverse,
    _zReverse,
    _rReverse,
    _xPadding,
    _yPadding,
    _zPadding,
    _rPadding,
    _xRange,
    _yRange,
    _zRange,
    _rRange,
    _xScale,
    _yScale,
    _zScale,
    _rScale,
    _xDomainSort,
    _yDomainSort,
    _zDomainSort,
    _rDomainSort,
    _config,
    _custom,
    _deriveScales,
    activeGetters_d,
    padding_d,
    box_d,
    width_d,
    height_d,
    extents_d,
    xDomain_d,
    yDomain_d,
    zDomain_d,
    rDomain_d,
    xScale_d,
    xGet_d,
    yScale_d,
    yGet_d,
    zScale_d,
    zGet_d,
    rScale_d,
    rGet_d,
    xRange_d,
    yRange_d,
    zRange_d,
    rRange_d,
    aspectRatio_d,
    percentRange,
    width,
    height,
    x,
    y,
    z,
    r,
    data,
    xDomain,
    yDomain,
    zDomain,
    rDomain,
    xNice,
    yNice,
    zNice,
    rNice,
    xPadding,
    yPadding,
    zPadding,
    rPadding,
    xScale,
    yScale,
    zScale,
    rScale,
    xRange,
    yRange,
    zRange,
    rRange,
    xReverse,
    yReverse,
    zReverse,
    rReverse,
    xDomainSort,
    yDomainSort,
    zDomainSort,
    rDomainSort,
    padding,
    extents,
    deriveScales,
    flatData,
    custom,
    debug,
    verbose,
    config,
    context,
    yReverseValue,
    $box_d,
    $_deriveScales,
    $$scope,
    slots,
    div_binding,
    div_elementresize_handler
  ];
}
var LayerCake = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        ssr: 3,
        pointerEvents: 4,
        position: 5,
        percentRange: 120,
        width: 121,
        height: 122,
        containerWidth: 0,
        containerHeight: 1,
        element: 2,
        x: 123,
        y: 124,
        z: 125,
        r: 126,
        data: 127,
        xDomain: 128,
        yDomain: 129,
        zDomain: 130,
        rDomain: 131,
        xNice: 132,
        yNice: 133,
        zNice: 134,
        rNice: 135,
        xPadding: 136,
        yPadding: 137,
        zPadding: 138,
        rPadding: 139,
        xScale: 140,
        yScale: 141,
        zScale: 142,
        rScale: 143,
        xRange: 144,
        yRange: 145,
        zRange: 146,
        rRange: 147,
        xReverse: 148,
        yReverse: 149,
        zReverse: 150,
        rReverse: 151,
        xDomainSort: 152,
        yDomainSort: 153,
        zDomainSort: 154,
        rDomainSort: 155,
        padding: 156,
        extents: 157,
        deriveScales: 158,
        flatData: 159,
        custom: 160,
        debug: 161,
        verbose: 162
      },
      add_css,
      [-1, -1, -1, -1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LayerCake",
      options,
      id: create_fragment.name
    });
  }
  get ssr() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ssr(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointerEvents() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointerEvents(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get percentRange() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set percentRange(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerWidth() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerWidth(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerHeight() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerHeight(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get z() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set z(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get r() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set r(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xDomain() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xDomain(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yDomain() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yDomain(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zDomain() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zDomain(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rDomain() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rDomain(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xNice() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xNice(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yNice() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yNice(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zNice() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zNice(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rNice() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rNice(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xPadding() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xPadding(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yPadding() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yPadding(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zPadding() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zPadding(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rPadding() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rPadding(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xScale() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xScale(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yScale() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yScale(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zScale() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zScale(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rScale() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rScale(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xRange() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xRange(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yRange() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yRange(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zRange() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zRange(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rRange() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rRange(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xReverse() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xReverse(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yReverse() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yReverse(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zReverse() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zReverse(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rReverse() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rReverse(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xDomainSort() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xDomainSort(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yDomainSort() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yDomainSort(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zDomainSort() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zDomainSort(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rDomainSort() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rDomainSort(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get extents() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set extents(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deriveScales() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deriveScales(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flatData() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flatData(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get custom() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set custom(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get debug() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set debug(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get verbose() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set verbose(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LayerCake_default = LayerCake;

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/layouts/Html.svelte
var file2 = "node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/layouts/Html.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1x3xzit", "div.svelte-1x3xzit{position:absolute;top:0;left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSHRtbC5zdmVsdGUiLCJzb3VyY2VzIjpbIkh0bWwuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjwhLS1cblx0QGNvbXBvbmVudFxuXHRIVE1MIGxheW91dCBjb21wb25lbnRcbiAtLT5cbjxzY3JpcHQ+XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXG5cdGNvbnN0IHsgcGFkZGluZyB9ID0gZ2V0Q29udGV4dCgnTGF5ZXJDYWtlJyk7XG5cblx0LyoqIEB0eXBlIHtFbGVtZW50fHVuZGVmaW5lZH0gW2VsZW1lbnRdIFRoZSBsYXllcidzIG91dGVybW9zdCBgPGRpdj5gIHRhZy4gVXNlZnVsIGZvciBiaW5kaW5ncy4gKi9cblx0ZXhwb3J0IGxldCBlbGVtZW50ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7TnVtYmVyfHVuZGVmaW5lZH0gW3pJbmRleF0gVGhlIGxheWVyJ3Mgei1pbmRleC4gKi9cblx0ZXhwb3J0IGxldCB6SW5kZXggPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gW3BvaW50ZXJFdmVudHNdIFNldCB0aGlzIHRvIGBmYWxzZWAgdG8gc2V0IGBwb2ludGVyLWV2ZW50czogbm9uZTtgIG9uIHRoZSBlbnRpcmUgbGF5ZXIuICovXG5cdGV4cG9ydCBsZXQgcG9pbnRlckV2ZW50cyA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge1N0cmluZ3x1bmRlZmluZWR9IFtyb2xlXSBBIHN0cmluZyBwYXNzZWQgdG8gdGhlIGBhcmlhLXJvbGVgIG9uIHRoZSBgPGRpdj5gIHRhZy4gVGhpcyBpcyBgdW5kZWZpbmVkYCBieSBkZWZhdWx0IGJ1dCB3aWxsIGJlIHNldCBieSBkZWZhdWx0IHRvIGAnZmlndXJlJ2AgaWYgYGxhYmVsYCwgYGxhYmVsbGVkYnlgIG9yIGBkZXNjcmliZWRieWAgaXMgc2V0LiBUaGF0IGRlZmF1bHQgd2lsbCBiZSBvdmVycmlkZGVuIGJ5IHdoYXRldmVyIGlzIHBhc3NlZCBpbi4gKi9cblx0ZXhwb3J0IGxldCByb2xlID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7U3RyaW5nfHVuZGVmaW5lZH0gW2xhYmVsXSBBIHN0cmluZyBwYXNzZWQgdG8gdGhlIGBhcmlhLWxhYmVsYCBvbiB0aGUgYDxkaXY+YCB0YWcuICovXG5cdGV4cG9ydCBsZXQgbGFiZWwgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtTdHJpbmd8dW5kZWZpbmVkfSBbbGFiZWxsZWRCeV0gQSBzdHJpbmcgcGFzc2VkIHRvIHRoZSBgYXJpYS1sYWJlbGxlZGJ5YCBvbiB0aGUgYDxkaXY+YCB0YWcuICovXG5cdGV4cG9ydCBsZXQgbGFiZWxsZWRCeSA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge1N0cmluZ3x1bmRlZmluZWR9IFtkZXNjcmliZWRCeV0gQSBzdHJpbmcgcGFzc2VkIHRvIGBhcmlhLWRlc2NyaWJlZGJ5YCBwcm9wZXJ0eSBvbiB0aGUgYDxkaXY+YCB0YWcuICovXG5cdGV4cG9ydCBsZXQgZGVzY3JpYmVkQnkgPSB1bmRlZmluZWQ7XG5cblx0JDogcm9sZVZhbCA9IHJvbGUgfHwgKGxhYmVsIHx8IGxhYmVsbGVkQnkgfHwgZGVzY3JpYmVkQnkgPyAnZmlndXJlJyA6IHVuZGVmaW5lZCk7XG48L3NjcmlwdD5cblxuPGRpdlxuXHRiaW5kOnRoaXM9e2VsZW1lbnR9XG5cdGNsYXNzPVwibGF5ZXJjYWtlLWxheW91dC1odG1sXCJcblx0c3R5bGU6ei1pbmRleD17ekluZGV4fVxuXHRzdHlsZTpwb2ludGVyLWV2ZW50cz17cG9pbnRlckV2ZW50cyA9PT0gZmFsc2UgPyAnbm9uZScgOiBudWxsfVxuXHRzdHlsZTp0b3A9eyRwYWRkaW5nLnRvcCArICdweCd9XG5cdHN0eWxlOnJpZ2h0PXskcGFkZGluZy5yaWdodCArICdweCd9XG5cdHN0eWxlOmJvdHRvbT17JHBhZGRpbmcuYm90dG9tICsgJ3B4J31cblx0c3R5bGU6bGVmdD17JHBhZGRpbmcubGVmdCArICdweCd9XG5cdHJvbGU9e3JvbGVWYWx9XG5cdGFyaWEtbGFiZWw9e2xhYmVsfVxuXHRhcmlhLWxhYmVsbGVkYnk9e2xhYmVsbGVkQnl9XG5cdGFyaWEtZGVzY3JpYmVkYnk9e2Rlc2NyaWJlZEJ5fVxuPlxuXHQ8c2xvdCB7ZWxlbWVudH0+PC9zbG90PlxuPC9kaXY+XG5cbjxzdHlsZT5cblx0ZGl2IHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBbURDLGtCQUFJLENBQ0gsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsQ0FDUCJ9 */");
}
var get_default_slot_changes2 = (dirty) => ({ element: dirty & /*element*/
1 });
var get_default_slot_context2 = (ctx) => ({ element: (
  /*element*/
  ctx[0]
) });
function create_fragment2(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "layercake-layout-html svelte-1x3xzit");
      attr_dev(
        div,
        "role",
        /*roleVal*/
        ctx[6]
      );
      attr_dev(
        div,
        "aria-label",
        /*label*/
        ctx[3]
      );
      attr_dev(
        div,
        "aria-labelledby",
        /*labelledBy*/
        ctx[4]
      );
      attr_dev(
        div,
        "aria-describedby",
        /*describedBy*/
        ctx[5]
      );
      set_style(
        div,
        "z-index",
        /*zIndex*/
        ctx[1]
      );
      set_style(
        div,
        "pointer-events",
        /*pointerEvents*/
        ctx[2] === false ? "none" : null
      );
      set_style(
        div,
        "top",
        /*$padding*/
        ctx[7].top + "px"
      );
      set_style(
        div,
        "right",
        /*$padding*/
        ctx[7].right + "px"
      );
      set_style(
        div,
        "bottom",
        /*$padding*/
        ctx[7].bottom + "px"
      );
      set_style(
        div,
        "left",
        /*$padding*/
        ctx[7].left + "px"
      );
      add_location(div, file2, 33, 0, 1357);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[12](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, element*/
        1025)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
      if (!current || dirty & /*roleVal*/
      64) {
        attr_dev(
          div,
          "role",
          /*roleVal*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*label*/
      8) {
        attr_dev(
          div,
          "aria-label",
          /*label*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*labelledBy*/
      16) {
        attr_dev(
          div,
          "aria-labelledby",
          /*labelledBy*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*describedBy*/
      32) {
        attr_dev(
          div,
          "aria-describedby",
          /*describedBy*/
          ctx2[5]
        );
      }
      if (dirty & /*zIndex*/
      2) {
        set_style(
          div,
          "z-index",
          /*zIndex*/
          ctx2[1]
        );
      }
      if (dirty & /*pointerEvents*/
      4) {
        set_style(
          div,
          "pointer-events",
          /*pointerEvents*/
          ctx2[2] === false ? "none" : null
        );
      }
      if (dirty & /*$padding*/
      128) {
        set_style(
          div,
          "top",
          /*$padding*/
          ctx2[7].top + "px"
        );
      }
      if (dirty & /*$padding*/
      128) {
        set_style(
          div,
          "right",
          /*$padding*/
          ctx2[7].right + "px"
        );
      }
      if (dirty & /*$padding*/
      128) {
        set_style(
          div,
          "bottom",
          /*$padding*/
          ctx2[7].bottom + "px"
        );
      }
      if (dirty & /*$padding*/
      128) {
        set_style(
          div,
          "left",
          /*$padding*/
          ctx2[7].left + "px"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[12](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let roleVal;
  let $padding;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Html", slots, ["default"]);
  const { padding } = getContext("LayerCake");
  validate_store(padding, "padding");
  component_subscribe($$self, padding, (value) => $$invalidate(7, $padding = value));
  let { element: element2 = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { pointerEvents = void 0 } = $$props;
  let { role = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { labelledBy = void 0 } = $$props;
  let { describedBy = void 0 } = $$props;
  const writable_props = [
    "element",
    "zIndex",
    "pointerEvents",
    "role",
    "label",
    "labelledBy",
    "describedBy"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Html> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("zIndex" in $$props2)
      $$invalidate(1, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(2, pointerEvents = $$props2.pointerEvents);
    if ("role" in $$props2)
      $$invalidate(9, role = $$props2.role);
    if ("label" in $$props2)
      $$invalidate(3, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(4, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(5, describedBy = $$props2.describedBy);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    padding,
    element: element2,
    zIndex,
    pointerEvents,
    role,
    label,
    labelledBy,
    describedBy,
    roleVal,
    $padding
  });
  $$self.$inject_state = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("zIndex" in $$props2)
      $$invalidate(1, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(2, pointerEvents = $$props2.pointerEvents);
    if ("role" in $$props2)
      $$invalidate(9, role = $$props2.role);
    if ("label" in $$props2)
      $$invalidate(3, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(4, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(5, describedBy = $$props2.describedBy);
    if ("roleVal" in $$props2)
      $$invalidate(6, roleVal = $$props2.roleVal);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*role, label, labelledBy, describedBy*/
    568) {
      $:
        $$invalidate(6, roleVal = role || (label || labelledBy || describedBy ? "figure" : void 0));
    }
  };
  return [
    element2,
    zIndex,
    pointerEvents,
    label,
    labelledBy,
    describedBy,
    roleVal,
    $padding,
    padding,
    role,
    $$scope,
    slots,
    div_binding
  ];
}
var Html = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        element: 0,
        zIndex: 1,
        pointerEvents: 2,
        role: 9,
        label: 3,
        labelledBy: 4,
        describedBy: 5
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Html",
      options,
      id: create_fragment2.name
    });
  }
  get element() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointerEvents() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointerEvents(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledBy() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledBy(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get describedBy() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set describedBy(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Html_default = Html;

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/layouts/Svg.svelte
var file3 = "node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/layouts/Svg.svelte";
function add_css3(target) {
  append_styles(target, "svelte-u84d8d", "svg.svelte-u84d8d{position:absolute;top:0;left:0;overflow:visible}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZnLnN2ZWx0ZSIsInNvdXJjZXMiOlsiU3ZnLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tXG5cdEBjb21wb25lbnRcblx0U1ZHIGxheW91dCBjb21wb25lbnRcbiAtLT5cbjxzY3JpcHQ+XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXG5cdC8qKiBAdHlwZSB7RWxlbWVudHx1bmRlZmluZWR9IFtlbGVtZW50XSBUaGUgbGF5ZXIncyBgPHN2Zz5gIHRhZy4gVXNlZnVsIGZvciBiaW5kaW5ncy4gKi9cblx0ZXhwb3J0IGxldCBlbGVtZW50ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7RWxlbWVudHx1bmRlZmluZWR9IFtpbm5lckVsZW1lbnRdIFRoZSBsYXllcidzIGA8Zz5gIHRhZy4gVXNlZnVsIGZvciBiaW5kaW5ncy4gKi9cblx0ZXhwb3J0IGxldCBpbm5lckVsZW1lbnQgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtOdW1iZXJ8dW5kZWZpbmVkfSBbekluZGV4XSBUaGUgbGF5ZXIncyB6LWluZGV4LiAqL1xuXHRleHBvcnQgbGV0IHpJbmRleCA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSBbcG9pbnRlckV2ZW50c10gU2V0IHRoaXMgdG8gYGZhbHNlYCB0byBzZXQgYHBvaW50ZXItZXZlbnRzOiBub25lO2Agb24gdGhlIGVudGlyZSBsYXllci4gKi9cblx0ZXhwb3J0IGxldCBwb2ludGVyRXZlbnRzID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7U3RyaW5nfHVuZGVmaW5lZH0gW3ZpZXdCb3hdIEEgc3RyaW5nIHBhc3NlZCB0byB0aGUgYHZpZXdCb3hgIHByb3BlcnR5IG9uIHRoZSBgPHN2Zz5gIHRhZy4gKi9cblx0ZXhwb3J0IGxldCB2aWV3Qm94ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7U3RyaW5nfHVuZGVmaW5lZH0gW2xhYmVsXSBBIHN0cmluZyBwYXNzZWQgdG8gdGhlIGBhcmlhLWxhYmVsYCBwcm9wZXJ0eSBvbiB0aGUgYDxzdmc+YCB0YWcuICovXG5cdGV4cG9ydCBsZXQgbGFiZWwgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtTdHJpbmd8dW5kZWZpbmVkfSBbbGFiZWxsZWRCeV0gQSBzdHJpbmcgcGFzc2VkIHRvIHRoZSBgYXJpYS1sYWJlbGxlZGJ5IHByb3BlcnR5YCBvbiB0aGUgYDxzdmc+YCB0YWcuICovXG5cdGV4cG9ydCBsZXQgbGFiZWxsZWRCeSA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge1N0cmluZ3x1bmRlZmluZWR9IFtkZXNjcmliZWRCeV0gQSBzdHJpbmcgcGFzc2VkIHRvIHRoZSBgYXJpYS1kZXNjcmliZWRieWAgcHJvcGVydHkgb24gdGhlIGA8c3ZnPmAgdGFnLiAqL1xuXHRleHBvcnQgbGV0IGRlc2NyaWJlZEJ5ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7U3RyaW5nfHVuZGVmaW5lZH0gW3RpdGxlXSBTaG9ydGhhbmQgdG8gc2V0IHRoZSBjb250ZW50cyBvZiBgPHRpdGxlPjwvdGl0bGU+YCBmb3IgYWNjZXNzaWJpbGl0eS4gWW91IGNhbiBhbHNvIHNldCBhcmJpdHJhcnkgSFRNTCB2aWEgdGhlIFwidGl0bGVcIiBzbG90IGJ1dCB0aGlzIGlzIGEgY29udmVuaWVudCBzaG9ydGhhbmQuIElmIHlvdSB1c2UgdGhlIFwidGl0bGVcIiBzbG90LCB0aGlzIHByb3AgaXMgaWdub3JlZC4gKi9cblx0ZXhwb3J0IGxldCB0aXRsZSA9IHVuZGVmaW5lZDtcblxuXHRjb25zdCB7IGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQsIHBhZGRpbmcgfSA9IGdldENvbnRleHQoJ0xheWVyQ2FrZScpO1xuPC9zY3JpcHQ+XG5cbjxzdmdcblx0YmluZDp0aGlzPXtlbGVtZW50fVxuXHRjbGFzcz1cImxheWVyY2FrZS1sYXlvdXQtc3ZnXCJcblx0e3ZpZXdCb3h9XG5cdHdpZHRoPXskY29udGFpbmVyV2lkdGh9XG5cdGhlaWdodD17JGNvbnRhaW5lckhlaWdodH1cblx0c3R5bGU6ei1pbmRleD17ekluZGV4fVxuXHRzdHlsZTpwb2ludGVyLWV2ZW50cz17cG9pbnRlckV2ZW50cyA9PT0gZmFsc2UgPyAnbm9uZScgOiBudWxsfVxuXHRhcmlhLWxhYmVsPXtsYWJlbH1cblx0YXJpYS1sYWJlbGxlZGJ5PXtsYWJlbGxlZEJ5fVxuXHRhcmlhLWRlc2NyaWJlZGJ5PXtkZXNjcmliZWRCeX1cbj5cblx0PHNsb3QgbmFtZT1cInRpdGxlXCJcblx0XHQ+eyNpZiB0aXRsZX08dGl0bGU+e3RpdGxlfTwvdGl0bGU+ey9pZn08L3Nsb3Rcblx0PlxuXG5cdDxkZWZzPlxuXHRcdDxzbG90IG5hbWU9XCJkZWZzXCI+PC9zbG90PlxuXHQ8L2RlZnM+XG5cdDxnXG5cdFx0YmluZDp0aGlzPXtpbm5lckVsZW1lbnR9XG5cdFx0Y2xhc3M9XCJsYXllcmNha2UtbGF5b3V0LXN2Z19nXCJcblx0XHR0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoeyRwYWRkaW5nLmxlZnR9LCB7JHBhZGRpbmcudG9wfSlcIlxuXHQ+XG5cdFx0PHNsb3Qge2VsZW1lbnR9Pjwvc2xvdD5cblx0PC9nPlxuPC9zdmc+XG5cbjxzdHlsZT5cblx0c3ZnIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0b3ZlcmZsb3c6IHZpc2libGU7XG5cdH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBa0VDLGlCQUFJLENBQ0gsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsQ0FBQyxDQUNQLFFBQVEsQ0FBRSxPQUNYIn0= */");
}
var get_default_slot_changes3 = (dirty) => ({ element: dirty & /*element*/
1 });
var get_default_slot_context3 = (ctx) => ({ element: (
  /*element*/
  ctx[0]
) });
var get_defs_slot_changes = (dirty) => ({ element: dirty & /*element*/
1 });
var get_defs_slot_context = (ctx) => ({ element: (
  /*element*/
  ctx[0]
) });
var get_title_slot_changes = (dirty) => ({ element: dirty & /*element*/
1 });
var get_title_slot_context = (ctx) => ({ element: (
  /*element*/
  ctx[0]
) });
function create_if_block2(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[8]
      );
      add_location(title_1, file3, 50, 14, 1890);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      256)
        set_data_dev(
          t,
          /*title*/
          ctx2[8]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(51:3) {#if title}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let if_block_anchor;
  let if_block = (
    /*title*/
    ctx[8] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*title*/
        ctx2[8]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(51:3) {#if title}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let svg;
  let defs;
  let g;
  let g_transform_value;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[16].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_title_slot_context
  );
  const title_slot_or_fallback = title_slot || fallback_block(ctx);
  const defs_slot_template = (
    /*#slots*/
    ctx[16].defs
  );
  const defs_slot = create_slot(
    defs_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_defs_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context3
  );
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
      defs = svg_element("defs");
      if (defs_slot)
        defs_slot.c();
      g = svg_element("g");
      if (default_slot)
        default_slot.c();
      add_location(defs, file3, 53, 1, 1929);
      attr_dev(g, "class", "layercake-layout-svg_g");
      attr_dev(g, "transform", g_transform_value = "translate(" + /*$padding*/
      ctx[11].left + ", " + /*$padding*/
      ctx[11].top + ")");
      add_location(g, file3, 56, 1, 1974);
      attr_dev(svg, "class", "layercake-layout-svg svelte-u84d8d");
      attr_dev(
        svg,
        "viewBox",
        /*viewBox*/
        ctx[4]
      );
      attr_dev(
        svg,
        "width",
        /*$containerWidth*/
        ctx[9]
      );
      attr_dev(
        svg,
        "height",
        /*$containerHeight*/
        ctx[10]
      );
      attr_dev(
        svg,
        "aria-label",
        /*label*/
        ctx[5]
      );
      attr_dev(
        svg,
        "aria-labelledby",
        /*labelledBy*/
        ctx[6]
      );
      attr_dev(
        svg,
        "aria-describedby",
        /*describedBy*/
        ctx[7]
      );
      set_style(
        svg,
        "z-index",
        /*zIndex*/
        ctx[2]
      );
      set_style(
        svg,
        "pointer-events",
        /*pointerEvents*/
        ctx[3] === false ? "none" : null
      );
      add_location(svg, file3, 37, 0, 1565);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(svg, null);
      }
      append_dev(svg, defs);
      if (defs_slot) {
        defs_slot.m(defs, null);
      }
      append_dev(svg, g);
      if (default_slot) {
        default_slot.m(g, null);
      }
      ctx[17](g);
      ctx[18](svg);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope, element*/
        32769)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_title_slot_changes
            ),
            get_title_slot_context
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & /*title*/
        256)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (defs_slot) {
        if (defs_slot.p && (!current || dirty & /*$$scope, element*/
        32769)) {
          update_slot_base(
            defs_slot,
            defs_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              defs_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_defs_slot_changes
            ),
            get_defs_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, element*/
        32769)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
      if (!current || dirty & /*$padding*/
      2048 && g_transform_value !== (g_transform_value = "translate(" + /*$padding*/
      ctx2[11].left + ", " + /*$padding*/
      ctx2[11].top + ")")) {
        attr_dev(g, "transform", g_transform_value);
      }
      if (!current || dirty & /*viewBox*/
      16) {
        attr_dev(
          svg,
          "viewBox",
          /*viewBox*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*$containerWidth*/
      512) {
        attr_dev(
          svg,
          "width",
          /*$containerWidth*/
          ctx2[9]
        );
      }
      if (!current || dirty & /*$containerHeight*/
      1024) {
        attr_dev(
          svg,
          "height",
          /*$containerHeight*/
          ctx2[10]
        );
      }
      if (!current || dirty & /*label*/
      32) {
        attr_dev(
          svg,
          "aria-label",
          /*label*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*labelledBy*/
      64) {
        attr_dev(
          svg,
          "aria-labelledby",
          /*labelledBy*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*describedBy*/
      128) {
        attr_dev(
          svg,
          "aria-describedby",
          /*describedBy*/
          ctx2[7]
        );
      }
      if (dirty & /*zIndex*/
      4) {
        set_style(
          svg,
          "z-index",
          /*zIndex*/
          ctx2[2]
        );
      }
      if (dirty & /*pointerEvents*/
      8) {
        set_style(
          svg,
          "pointer-events",
          /*pointerEvents*/
          ctx2[3] === false ? "none" : null
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot_or_fallback, local);
      transition_in(defs_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot_or_fallback, local);
      transition_out(defs_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
      if (defs_slot)
        defs_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      ctx[17](null);
      ctx[18](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $containerWidth;
  let $containerHeight;
  let $padding;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Svg", slots, ["title", "defs", "default"]);
  let { element: element2 = void 0 } = $$props;
  let { innerElement = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { pointerEvents = void 0 } = $$props;
  let { viewBox = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { labelledBy = void 0 } = $$props;
  let { describedBy = void 0 } = $$props;
  let { title = void 0 } = $$props;
  const { containerWidth, containerHeight, padding } = getContext("LayerCake");
  validate_store(containerWidth, "containerWidth");
  component_subscribe($$self, containerWidth, (value) => $$invalidate(9, $containerWidth = value));
  validate_store(containerHeight, "containerHeight");
  component_subscribe($$self, containerHeight, (value) => $$invalidate(10, $containerHeight = value));
  validate_store(padding, "padding");
  component_subscribe($$self, padding, (value) => $$invalidate(11, $padding = value));
  const writable_props = [
    "element",
    "innerElement",
    "zIndex",
    "pointerEvents",
    "viewBox",
    "label",
    "labelledBy",
    "describedBy",
    "title"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Svg> was created with unknown prop '${key}'`);
  });
  function g_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerElement = $$value;
      $$invalidate(1, innerElement);
    });
  }
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("innerElement" in $$props2)
      $$invalidate(1, innerElement = $$props2.innerElement);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("viewBox" in $$props2)
      $$invalidate(4, viewBox = $$props2.viewBox);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(6, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(7, describedBy = $$props2.describedBy);
    if ("title" in $$props2)
      $$invalidate(8, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(15, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    element: element2,
    innerElement,
    zIndex,
    pointerEvents,
    viewBox,
    label,
    labelledBy,
    describedBy,
    title,
    containerWidth,
    containerHeight,
    padding,
    $containerWidth,
    $containerHeight,
    $padding
  });
  $$self.$inject_state = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("innerElement" in $$props2)
      $$invalidate(1, innerElement = $$props2.innerElement);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("viewBox" in $$props2)
      $$invalidate(4, viewBox = $$props2.viewBox);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(6, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(7, describedBy = $$props2.describedBy);
    if ("title" in $$props2)
      $$invalidate(8, title = $$props2.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    innerElement,
    zIndex,
    pointerEvents,
    viewBox,
    label,
    labelledBy,
    describedBy,
    title,
    $containerWidth,
    $containerHeight,
    $padding,
    containerWidth,
    containerHeight,
    padding,
    $$scope,
    slots,
    g_binding,
    svg_binding
  ];
}
var Svg = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        element: 0,
        innerElement: 1,
        zIndex: 2,
        pointerEvents: 3,
        viewBox: 4,
        label: 5,
        labelledBy: 6,
        describedBy: 7,
        title: 8
      },
      add_css3
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Svg",
      options,
      id: create_fragment3.name
    });
  }
  get element() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get innerElement() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set innerElement(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointerEvents() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointerEvents(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewBox() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewBox(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledBy() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledBy(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get describedBy() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set describedBy(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Svg_default = Svg;

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/layouts/ScaledSvg.svelte
var file4 = "node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/layouts/ScaledSvg.svelte";
function add_css4(target) {
  append_styles(target, "svelte-6sm8ei", "svg.svelte-6sm8ei{position:absolute;width:100%;height:100%;overflow:visible}svg.svelte-6sm8ei *{vector-effect:non-scaling-stroke}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NhbGVkU3ZnLnN2ZWx0ZSIsInNvdXJjZXMiOlsiU2NhbGVkU3ZnLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tXG5cdEBjb21wb25lbnRcblx0U2NhbGVkIFNWRyBsYXlvdXQgY29tcG9uZW50XG4gLS0+XG48c2NyaXB0PlxuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblxuXHRjb25zdCB7IHBhZGRpbmcgfSA9IGdldENvbnRleHQoJ0xheWVyQ2FrZScpO1xuXG5cdC8qKiBAdHlwZSB7RWxlbWVudHx1bmRlZmluZWR9IFtlbGVtZW50XSBUaGUgbGF5ZXIncyBgPHN2Zz5gIHRhZy4gVXNlZnVsIGZvciBiaW5kaW5ncy4gKi9cblx0ZXhwb3J0IGxldCBlbGVtZW50ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7TnVtYmVyfHVuZGVmaW5lZH0gW3pJbmRleF0gVGhlIGxheWVyJ3Mgei1pbmRleC4gKi9cblx0ZXhwb3J0IGxldCB6SW5kZXggPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gW3BvaW50ZXJFdmVudHNdIFNldCB0aGlzIHRvIGBmYWxzZWAgdG8gc2V0IGBwb2ludGVyLWV2ZW50czogbm9uZTtgIG9uIHRoZSBlbnRpcmUgbGF5ZXIuICovXG5cdGV4cG9ydCBsZXQgcG9pbnRlckV2ZW50cyA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge051bWJlcn0gW2ZpeGVkQXNwZWN0UmF0aW89MV0gQSBudW1iZXIgdG8gc2V0IHRoZSBhc3BlY3QgcmF0aW8gb250byB0aGUgdmlld0JveC4gKi9cblx0ZXhwb3J0IGxldCBmaXhlZEFzcGVjdFJhdGlvID0gMTtcblxuXHQvKiogQHR5cGUge1N0cmluZ30gW3ZpZXdCb3g9YDAgMCAxMDAgJHsxMDAgLyBmaXhlZEFzcGVjdFJhdGlvfWBdIEEgc3RyaW5nIHBhc3NlZCB0byB0aGUgYHZpZXdCb3hgIHByb3BlcnR5IG9uIHRoZSBgPHN2Zz5gIHRhZy4gKi9cblx0ZXhwb3J0IGxldCB2aWV3Qm94ID0gYDAgMCAxMDAgJHsxMDAgLyBmaXhlZEFzcGVjdFJhdGlvfWA7XG5cdCQ6IHZpZXdCb3ggPSBgMCAwIDEwMCAkezEwMCAvIGZpeGVkQXNwZWN0UmF0aW99YDtcblxuXHQvKiogQHR5cGUge1N0cmluZ3x1bmRlZmluZWR9IFtsYWJlbF0gQSBzdHJpbmcgcGFzc2VkIHRvIHRoZSBgYXJpYS1sYWJlbGAgb24gdGhlIGA8c3ZnPmAgdGFnLiAqL1xuXHRleHBvcnQgbGV0IGxhYmVsID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7U3RyaW5nfHVuZGVmaW5lZH0gW2xhYmVsbGVkQnldIEEgc3RyaW5nIHBhc3NlZCB0byB0aGUgYGFyaWEtbGFiZWxsZWRieWAgb24gdGhlIGA8c3ZnPmAgdGFnLiAqL1xuXHRleHBvcnQgbGV0IGxhYmVsbGVkQnkgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtTdHJpbmd8dW5kZWZpbmVkfSBbZGVzY3JpYmVkQnldIEEgc3RyaW5nIHBhc3NlZCB0byBgYXJpYS1kZXNjcmliZWRieWAgcHJvcGVydHkgb24gdGhlIGA8c3ZnPmAgdGFnLiAqL1xuXHRleHBvcnQgbGV0IGRlc2NyaWJlZEJ5ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7U3RyaW5nfHVuZGVmaW5lZH0gW3RpdGxlXSBTaG9ydGhhbmQgdG8gc2V0IHRoZSBjb250ZW50cyBvZiBgPHRpdGxlPjwvdGl0bGU+YCBmb3IgYWNjZXNzaWJpbGl0eS4gWW91IGNhbiBhbHNvIHNldCBhcmJpdHJhcnkgSFRNTCB2aWEgdGhlIFwidGl0bGVcIiBzbG90IGJ1dCB0aGlzIGlzIGEgY29udmVuaWVudCBzaG9ydGhhbmQuIElmIHlvdSB1c2UgdGhlIFwidGl0bGVcIiBzbG90LCB0aGlzIHByb3AgaXMgaWdub3JlZC4gKi9cblx0ZXhwb3J0IGxldCB0aXRsZSA9IHVuZGVmaW5lZDtcbjwvc2NyaXB0PlxuXG48c3ZnXG5cdGJpbmQ6dGhpcz17ZWxlbWVudH1cblx0e3ZpZXdCb3h9XG5cdHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCJcblx0c3R5bGU6ei1pbmRleD17ekluZGV4fVxuXHRzdHlsZTpwb2ludGVyLWV2ZW50cz17cG9pbnRlckV2ZW50cyA9PT0gZmFsc2UgPyAnbm9uZScgOiBudWxsfVxuXHRzdHlsZTp0b3A9eyRwYWRkaW5nLnRvcCArICdweCd9XG5cdHN0eWxlOmxlZnQ9eyRwYWRkaW5nLmxlZnQgKyAncHgnfVxuXHRzdHlsZTp3aWR0aD17YGNhbGMoMTAwJSAtICR7JHBhZGRpbmcubGVmdCArICRwYWRkaW5nLnJpZ2h0fXB4KWB9XG5cdHN0eWxlOmhlaWdodD17YGNhbGMoMTAwJSAtICR7JHBhZGRpbmcudG9wICsgJHBhZGRpbmcuYm90dG9tfXB4KWB9XG5cdHN0eWxlPVwicmlnaHQ6MHB4OyBib3R0b206MHB4O1wiXG5cdGFyaWEtbGFiZWw9e2xhYmVsfVxuXHRhcmlhLWxhYmVsbGVkYnk9e2xhYmVsbGVkQnl9XG5cdGFyaWEtZGVzY3JpYmVkYnk9e2Rlc2NyaWJlZEJ5fVxuPlxuXHQ8c2xvdCBuYW1lPVwidGl0bGVcIlxuXHRcdD57I2lmIHRpdGxlfTx0aXRsZT57dGl0bGV9PC90aXRsZT57L2lmfTwvc2xvdFxuXHQ+XG5cblx0PGRlZnM+XG5cdFx0PHNsb3QgbmFtZT1cImRlZnNcIj48L3Nsb3Q+XG5cdDwvZGVmcz5cblxuXHQ8c2xvdCB7ZWxlbWVudH0+PC9zbG90PlxuPC9zdmc+XG5cbjxzdHlsZT5cblx0c3ZnIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdG92ZXJmbG93OiB2aXNpYmxlO1xuXHR9XG5cdHN2ZyA6Z2xvYmFsKCopIHtcblx0XHR2ZWN0b3ItZWZmZWN0OiBub24tc2NhbGluZy1zdHJva2U7XG5cdH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUVDLGlCQUFJLENBQ0gsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLFFBQVEsQ0FBRSxPQUNYLENBQ0EsaUJBQUcsQ0FBUyxDQUFHLENBQ2QsYUFBYSxDQUFFLGtCQUNoQiJ9 */");
}
var get_default_slot_changes4 = (dirty) => ({ element: dirty & /*element*/
1 });
var get_default_slot_context4 = (ctx) => ({ element: (
  /*element*/
  ctx[0]
) });
var get_defs_slot_changes2 = (dirty) => ({ element: dirty & /*element*/
1 });
var get_defs_slot_context2 = (ctx) => ({ element: (
  /*element*/
  ctx[0]
) });
var get_title_slot_changes2 = (dirty) => ({ element: dirty & /*element*/
1 });
var get_title_slot_context2 = (ctx) => ({ element: (
  /*element*/
  ctx[0]
) });
function create_if_block3(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[7]
      );
      add_location(title_1, file4, 54, 14, 2122);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      128)
        set_data_dev(
          t,
          /*title*/
          ctx2[7]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(55:3) {#if title}",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let if_block_anchor;
  let if_block = (
    /*title*/
    ctx[7] && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*title*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(55:3) {#if title}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let svg;
  let defs;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[12].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_title_slot_context2
  );
  const title_slot_or_fallback = title_slot || fallback_block2(ctx);
  const defs_slot_template = (
    /*#slots*/
    ctx[12].defs
  );
  const defs_slot = create_slot(
    defs_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_defs_slot_context2
  );
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context4
  );
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
      defs = svg_element("defs");
      if (defs_slot)
        defs_slot.c();
      if (default_slot)
        default_slot.c();
      add_location(defs, file4, 57, 1, 2161);
      attr_dev(
        svg,
        "viewBox",
        /*viewBox*/
        ctx[1]
      );
      attr_dev(svg, "preserveAspectRatio", "none");
      set_style(svg, "right", "0px");
      set_style(svg, "bottom", "0px");
      attr_dev(
        svg,
        "aria-label",
        /*label*/
        ctx[4]
      );
      attr_dev(
        svg,
        "aria-labelledby",
        /*labelledBy*/
        ctx[5]
      );
      attr_dev(
        svg,
        "aria-describedby",
        /*describedBy*/
        ctx[6]
      );
      attr_dev(svg, "class", "svelte-6sm8ei");
      set_style(
        svg,
        "z-index",
        /*zIndex*/
        ctx[2]
      );
      set_style(
        svg,
        "pointer-events",
        /*pointerEvents*/
        ctx[3] === false ? "none" : null
      );
      set_style(
        svg,
        "top",
        /*$padding*/
        ctx[8].top + "px"
      );
      set_style(
        svg,
        "left",
        /*$padding*/
        ctx[8].left + "px"
      );
      set_style(svg, "width", `calc(100% - ${/*$padding*/
      ctx[8].left + /*$padding*/
      ctx[8].right}px)`);
      set_style(svg, "height", `calc(100% - ${/*$padding*/
      ctx[8].top + /*$padding*/
      ctx[8].bottom}px)`);
      add_location(svg, file4, 38, 0, 1618);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(svg, null);
      }
      append_dev(svg, defs);
      if (defs_slot) {
        defs_slot.m(defs, null);
      }
      if (default_slot) {
        default_slot.m(svg, null);
      }
      ctx[13](svg);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope, element*/
        2049)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_title_slot_changes2
            ),
            get_title_slot_context2
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & /*title*/
        128)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (defs_slot) {
        if (defs_slot.p && (!current || dirty & /*$$scope, element*/
        2049)) {
          update_slot_base(
            defs_slot,
            defs_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              defs_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_defs_slot_changes2
            ),
            get_defs_slot_context2
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, element*/
        2049)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes4
            ),
            get_default_slot_context4
          );
        }
      }
      if (!current || dirty & /*viewBox*/
      2) {
        attr_dev(
          svg,
          "viewBox",
          /*viewBox*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*label*/
      16) {
        attr_dev(
          svg,
          "aria-label",
          /*label*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*labelledBy*/
      32) {
        attr_dev(
          svg,
          "aria-labelledby",
          /*labelledBy*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*describedBy*/
      64) {
        attr_dev(
          svg,
          "aria-describedby",
          /*describedBy*/
          ctx2[6]
        );
      }
      if (dirty & /*zIndex*/
      4) {
        set_style(
          svg,
          "z-index",
          /*zIndex*/
          ctx2[2]
        );
      }
      if (dirty & /*pointerEvents*/
      8) {
        set_style(
          svg,
          "pointer-events",
          /*pointerEvents*/
          ctx2[3] === false ? "none" : null
        );
      }
      if (dirty & /*$padding*/
      256) {
        set_style(
          svg,
          "top",
          /*$padding*/
          ctx2[8].top + "px"
        );
      }
      if (dirty & /*$padding*/
      256) {
        set_style(
          svg,
          "left",
          /*$padding*/
          ctx2[8].left + "px"
        );
      }
      if (dirty & /*$padding*/
      256) {
        set_style(svg, "width", `calc(100% - ${/*$padding*/
        ctx2[8].left + /*$padding*/
        ctx2[8].right}px)`);
      }
      if (dirty & /*$padding*/
      256) {
        set_style(svg, "height", `calc(100% - ${/*$padding*/
        ctx2[8].top + /*$padding*/
        ctx2[8].bottom}px)`);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot_or_fallback, local);
      transition_in(defs_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot_or_fallback, local);
      transition_out(defs_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
      if (defs_slot)
        defs_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      ctx[13](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $padding;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ScaledSvg", slots, ["title", "defs", "default"]);
  const { padding } = getContext("LayerCake");
  validate_store(padding, "padding");
  component_subscribe($$self, padding, (value) => $$invalidate(8, $padding = value));
  let { element: element2 = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { pointerEvents = void 0 } = $$props;
  let { fixedAspectRatio = 1 } = $$props;
  let { viewBox = `0 0 100 ${100 / fixedAspectRatio}` } = $$props;
  let { label = void 0 } = $$props;
  let { labelledBy = void 0 } = $$props;
  let { describedBy = void 0 } = $$props;
  let { title = void 0 } = $$props;
  const writable_props = [
    "element",
    "zIndex",
    "pointerEvents",
    "fixedAspectRatio",
    "viewBox",
    "label",
    "labelledBy",
    "describedBy",
    "title"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ScaledSvg> was created with unknown prop '${key}'`);
  });
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("fixedAspectRatio" in $$props2)
      $$invalidate(10, fixedAspectRatio = $$props2.fixedAspectRatio);
    if ("viewBox" in $$props2)
      $$invalidate(1, viewBox = $$props2.viewBox);
    if ("label" in $$props2)
      $$invalidate(4, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(5, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(6, describedBy = $$props2.describedBy);
    if ("title" in $$props2)
      $$invalidate(7, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(11, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    padding,
    element: element2,
    zIndex,
    pointerEvents,
    fixedAspectRatio,
    viewBox,
    label,
    labelledBy,
    describedBy,
    title,
    $padding
  });
  $$self.$inject_state = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("fixedAspectRatio" in $$props2)
      $$invalidate(10, fixedAspectRatio = $$props2.fixedAspectRatio);
    if ("viewBox" in $$props2)
      $$invalidate(1, viewBox = $$props2.viewBox);
    if ("label" in $$props2)
      $$invalidate(4, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(5, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(6, describedBy = $$props2.describedBy);
    if ("title" in $$props2)
      $$invalidate(7, title = $$props2.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*fixedAspectRatio*/
    1024) {
      $:
        $$invalidate(1, viewBox = `0 0 100 ${100 / fixedAspectRatio}`);
    }
  };
  return [
    element2,
    viewBox,
    zIndex,
    pointerEvents,
    label,
    labelledBy,
    describedBy,
    title,
    $padding,
    padding,
    fixedAspectRatio,
    $$scope,
    slots,
    svg_binding
  ];
}
var ScaledSvg = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        element: 0,
        zIndex: 2,
        pointerEvents: 3,
        fixedAspectRatio: 10,
        viewBox: 1,
        label: 4,
        labelledBy: 5,
        describedBy: 6,
        title: 7
      },
      add_css4
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScaledSvg",
      options,
      id: create_fragment4.name
    });
  }
  get element() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointerEvents() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointerEvents(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixedAspectRatio() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixedAspectRatio(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewBox() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewBox(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledBy() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledBy(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get describedBy() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set describedBy(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ScaledSvg_default = ScaledSvg;

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/lib/scaleCanvas.js
function scaleCanvas_default(ctx, width, height) {
  const dpr = window.devicePixelRatio || 1;
  ctx.canvas.width = width * dpr;
  ctx.canvas.height = height * dpr;
  ctx.canvas.style.width = `${width}px`;
  ctx.canvas.style.height = `${height}px`;
  ctx.scale(dpr, dpr);
  return { width: ctx.canvas.width, height: ctx.canvas.height };
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/layouts/Canvas.svelte
var file5 = "node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/layouts/Canvas.svelte";
var get_default_slot_changes5 = (dirty) => ({
  element: dirty & /*element*/
  2,
  context: dirty & /*context*/
  1
});
var get_default_slot_context5 = (ctx) => ({
  element: (
    /*element*/
    ctx[1]
  ),
  context: (
    /*context*/
    ctx[0]
  )
});
var get_fallback_slot_changes = (dirty) => ({
  element: dirty & /*element*/
  2,
  context: dirty & /*context*/
  1
});
var get_fallback_slot_context = (ctx) => ({
  element: (
    /*element*/
    ctx[1]
  ),
  context: (
    /*context*/
    ctx[0]
  )
});
function create_if_block4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*fallback*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*fallback*/
      16)
        set_data_dev(
          t,
          /*fallback*/
          ctx2[4]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(63:3) {#if fallback}",
    ctx
  });
  return block;
}
function fallback_block3(ctx) {
  let if_block_anchor;
  let if_block = (
    /*fallback*/
    ctx[4] && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*fallback*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block3.name,
    type: "fallback",
    source: "(63:3) {#if fallback}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let canvas;
  let t;
  let current;
  const fallback_slot_template = (
    /*#slots*/
    ctx[13].fallback
  );
  const fallback_slot = create_slot(
    fallback_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_fallback_slot_context
  );
  const fallback_slot_or_fallback = fallback_slot || fallback_block3(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context5
  );
  const block = {
    c: function create() {
      canvas = element("canvas");
      if (fallback_slot_or_fallback)
        fallback_slot_or_fallback.c();
      t = space();
      if (default_slot)
        default_slot.c();
      attr_dev(canvas, "class", "layercake-layout-canvas");
      set_style(canvas, "width", "100%");
      set_style(canvas, "height", "100%");
      set_style(canvas, "position", "absolute");
      attr_dev(
        canvas,
        "aria-label",
        /*label*/
        ctx[5]
      );
      attr_dev(
        canvas,
        "aria-labelledby",
        /*labelledBy*/
        ctx[6]
      );
      attr_dev(
        canvas,
        "aria-describedby",
        /*describedBy*/
        ctx[7]
      );
      set_style(
        canvas,
        "z-index",
        /*zIndex*/
        ctx[2]
      );
      set_style(
        canvas,
        "pointer-events",
        /*pointerEvents*/
        ctx[3] === false ? "none" : null
      );
      set_style(
        canvas,
        "top",
        /*$padding*/
        ctx[8].top + "px"
      );
      set_style(
        canvas,
        "right",
        /*$padding*/
        ctx[8].right + "px"
      );
      set_style(
        canvas,
        "bottom",
        /*$padding*/
        ctx[8].bottom + "px"
      );
      set_style(
        canvas,
        "left",
        /*$padding*/
        ctx[8].left + "px"
      );
      add_location(canvas, file5, 48, 0, 1719);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, canvas, anchor);
      if (fallback_slot_or_fallback) {
        fallback_slot_or_fallback.m(canvas, null);
      }
      ctx[14](canvas);
      insert_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (fallback_slot) {
        if (fallback_slot.p && (!current || dirty & /*$$scope, element, context*/
        4099)) {
          update_slot_base(
            fallback_slot,
            fallback_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              fallback_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_fallback_slot_changes
            ),
            get_fallback_slot_context
          );
        }
      } else {
        if (fallback_slot_or_fallback && fallback_slot_or_fallback.p && (!current || dirty & /*fallback*/
        16)) {
          fallback_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*label*/
      32) {
        attr_dev(
          canvas,
          "aria-label",
          /*label*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*labelledBy*/
      64) {
        attr_dev(
          canvas,
          "aria-labelledby",
          /*labelledBy*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*describedBy*/
      128) {
        attr_dev(
          canvas,
          "aria-describedby",
          /*describedBy*/
          ctx2[7]
        );
      }
      if (dirty & /*zIndex*/
      4) {
        set_style(
          canvas,
          "z-index",
          /*zIndex*/
          ctx2[2]
        );
      }
      if (dirty & /*pointerEvents*/
      8) {
        set_style(
          canvas,
          "pointer-events",
          /*pointerEvents*/
          ctx2[3] === false ? "none" : null
        );
      }
      if (dirty & /*$padding*/
      256) {
        set_style(
          canvas,
          "top",
          /*$padding*/
          ctx2[8].top + "px"
        );
      }
      if (dirty & /*$padding*/
      256) {
        set_style(
          canvas,
          "right",
          /*$padding*/
          ctx2[8].right + "px"
        );
      }
      if (dirty & /*$padding*/
      256) {
        set_style(
          canvas,
          "bottom",
          /*$padding*/
          ctx2[8].bottom + "px"
        );
      }
      if (dirty & /*$padding*/
      256) {
        set_style(
          canvas,
          "left",
          /*$padding*/
          ctx2[8].left + "px"
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, element, context*/
        4099)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes5
            ),
            get_default_slot_context5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(fallback_slot_or_fallback, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(fallback_slot_or_fallback, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(canvas);
      if (fallback_slot_or_fallback)
        fallback_slot_or_fallback.d(detaching);
      ctx[14](null);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let $height;
  let $width;
  let $padding;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Canvas", slots, ["fallback", "default"]);
  const { width, height, padding } = getContext("LayerCake");
  validate_store(width, "width");
  component_subscribe($$self, width, (value) => $$invalidate(16, $width = value));
  validate_store(height, "height");
  component_subscribe($$self, height, (value) => $$invalidate(15, $height = value));
  validate_store(padding, "padding");
  component_subscribe($$self, padding, (value) => $$invalidate(8, $padding = value));
  let { element: element2 = void 0 } = $$props;
  let { context = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { pointerEvents = void 0 } = $$props;
  let { fallback = "" } = $$props;
  let { label = void 0 } = $$props;
  let { labelledBy = void 0 } = $$props;
  let { describedBy = void 0 } = $$props;
  const cntxt = { ctx: writable({}) };
  onMount(() => {
    $$invalidate(0, context = element2.getContext("2d"));
    scaleCanvas_default(context, $width, $height);
  });
  setContext("canvas", cntxt);
  const writable_props = [
    "element",
    "context",
    "zIndex",
    "pointerEvents",
    "fallback",
    "label",
    "labelledBy",
    "describedBy"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Canvas> was created with unknown prop '${key}'`);
  });
  function canvas_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(1, element2 = $$props2.element);
    if ("context" in $$props2)
      $$invalidate(0, context = $$props2.context);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("fallback" in $$props2)
      $$invalidate(4, fallback = $$props2.fallback);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(6, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(7, describedBy = $$props2.describedBy);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    setContext,
    writable,
    scaleCanvas: scaleCanvas_default,
    width,
    height,
    padding,
    element: element2,
    context,
    zIndex,
    pointerEvents,
    fallback,
    label,
    labelledBy,
    describedBy,
    cntxt,
    $height,
    $width,
    $padding
  });
  $$self.$inject_state = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(1, element2 = $$props2.element);
    if ("context" in $$props2)
      $$invalidate(0, context = $$props2.context);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("fallback" in $$props2)
      $$invalidate(4, fallback = $$props2.fallback);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(6, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(7, describedBy = $$props2.describedBy);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*context*/
    1) {
      $:
        cntxt.ctx.set(context);
    }
  };
  return [
    context,
    element2,
    zIndex,
    pointerEvents,
    fallback,
    label,
    labelledBy,
    describedBy,
    $padding,
    width,
    height,
    padding,
    $$scope,
    slots,
    canvas_binding
  ];
}
var Canvas = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      element: 1,
      context: 0,
      zIndex: 2,
      pointerEvents: 3,
      fallback: 4,
      label: 5,
      labelledBy: 6,
      describedBy: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Canvas",
      options,
      id: create_fragment5.name
    });
  }
  get element() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointerEvents() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointerEvents(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fallback() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fallback(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledBy() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledBy(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get describedBy() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set describedBy(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Canvas_default = Canvas;

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/layouts/Webgl.svelte
var file6 = "node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/layouts/Webgl.svelte";
var get_default_slot_changes6 = (dirty) => ({
  element: dirty & /*element*/
  2,
  context: dirty & /*context*/
  1
});
var get_default_slot_context6 = (ctx) => ({
  element: (
    /*element*/
    ctx[1]
  ),
  context: (
    /*context*/
    ctx[0]
  )
});
var get_fallback_slot_changes2 = (dirty) => ({
  element: dirty & /*element*/
  2,
  context: dirty & /*context*/
  1
});
var get_fallback_slot_context2 = (ctx) => ({
  element: (
    /*element*/
    ctx[1]
  ),
  context: (
    /*context*/
    ctx[0]
  )
});
function create_if_block5(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*fallback*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*fallback*/
      16)
        set_data_dev(
          t,
          /*fallback*/
          ctx2[4]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(77:3) {#if fallback}",
    ctx
  });
  return block;
}
function fallback_block4(ctx) {
  let if_block_anchor;
  let if_block = (
    /*fallback*/
    ctx[4] && create_if_block5(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*fallback*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block4.name,
    type: "fallback",
    source: "(77:3) {#if fallback}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let canvas;
  let t;
  let current;
  const fallback_slot_template = (
    /*#slots*/
    ctx[12].fallback
  );
  const fallback_slot = create_slot(
    fallback_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_fallback_slot_context2
  );
  const fallback_slot_or_fallback = fallback_slot || fallback_block4(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context6
  );
  const block = {
    c: function create() {
      canvas = element("canvas");
      if (fallback_slot_or_fallback)
        fallback_slot_or_fallback.c();
      t = space();
      if (default_slot)
        default_slot.c();
      attr_dev(canvas, "class", "layercake-layout-webgl");
      set_style(canvas, "width", "100%");
      set_style(canvas, "height", "100%");
      set_style(canvas, "position", "absolute");
      attr_dev(
        canvas,
        "aria-label",
        /*label*/
        ctx[5]
      );
      attr_dev(
        canvas,
        "aria-labelledby",
        /*labelledBy*/
        ctx[6]
      );
      attr_dev(
        canvas,
        "aria-describedby",
        /*describedBy*/
        ctx[7]
      );
      set_style(
        canvas,
        "z-index",
        /*zIndex*/
        ctx[2]
      );
      set_style(
        canvas,
        "pointer-events",
        /*pointerEvents*/
        ctx[3] === false ? "none" : null
      );
      set_style(
        canvas,
        "top",
        /*$padding*/
        ctx[8].top + "px"
      );
      set_style(
        canvas,
        "right",
        /*$padding*/
        ctx[8].right + "px"
      );
      set_style(
        canvas,
        "bottom",
        /*$padding*/
        ctx[8].bottom + "px"
      );
      set_style(
        canvas,
        "left",
        /*$padding*/
        ctx[8].left + "px"
      );
      add_location(canvas, file6, 62, 0, 2227);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, canvas, anchor);
      if (fallback_slot_or_fallback) {
        fallback_slot_or_fallback.m(canvas, null);
      }
      ctx[13](canvas);
      insert_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (fallback_slot) {
        if (fallback_slot.p && (!current || dirty & /*$$scope, element, context*/
        2051)) {
          update_slot_base(
            fallback_slot,
            fallback_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              fallback_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_fallback_slot_changes2
            ),
            get_fallback_slot_context2
          );
        }
      } else {
        if (fallback_slot_or_fallback && fallback_slot_or_fallback.p && (!current || dirty & /*fallback*/
        16)) {
          fallback_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*label*/
      32) {
        attr_dev(
          canvas,
          "aria-label",
          /*label*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*labelledBy*/
      64) {
        attr_dev(
          canvas,
          "aria-labelledby",
          /*labelledBy*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*describedBy*/
      128) {
        attr_dev(
          canvas,
          "aria-describedby",
          /*describedBy*/
          ctx2[7]
        );
      }
      if (dirty & /*zIndex*/
      4) {
        set_style(
          canvas,
          "z-index",
          /*zIndex*/
          ctx2[2]
        );
      }
      if (dirty & /*pointerEvents*/
      8) {
        set_style(
          canvas,
          "pointer-events",
          /*pointerEvents*/
          ctx2[3] === false ? "none" : null
        );
      }
      if (dirty & /*$padding*/
      256) {
        set_style(
          canvas,
          "top",
          /*$padding*/
          ctx2[8].top + "px"
        );
      }
      if (dirty & /*$padding*/
      256) {
        set_style(
          canvas,
          "right",
          /*$padding*/
          ctx2[8].right + "px"
        );
      }
      if (dirty & /*$padding*/
      256) {
        set_style(
          canvas,
          "bottom",
          /*$padding*/
          ctx2[8].bottom + "px"
        );
      }
      if (dirty & /*$padding*/
      256) {
        set_style(
          canvas,
          "left",
          /*$padding*/
          ctx2[8].left + "px"
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, element, context*/
        2051)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes6
            ),
            get_default_slot_context6
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(fallback_slot_or_fallback, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(fallback_slot_or_fallback, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(canvas);
      if (fallback_slot_or_fallback)
        fallback_slot_or_fallback.d(detaching);
      ctx[13](null);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let $padding;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Webgl", slots, ["fallback", "default"]);
  let { element: element2 = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { pointerEvents = void 0 } = $$props;
  let { contextAttributes = void 0 } = $$props;
  let { context = void 0 } = $$props;
  let { fallback = "" } = $$props;
  let { label = void 0 } = $$props;
  let { labelledBy = void 0 } = $$props;
  let { describedBy = void 0 } = $$props;
  let testGl;
  const { padding } = getContext("LayerCake");
  validate_store(padding, "padding");
  component_subscribe($$self, padding, (value) => $$invalidate(8, $padding = value));
  const cntxt = { gl: writable({}) };
  onMount(() => {
    const contexts = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"];
    for (let j = 0; j < contexts.length; j++) {
      testGl = element2.getContext(contexts[j], contextAttributes);
      if (testGl) {
        $$invalidate(0, context = testGl);
        break;
      }
    }
  });
  setContext("gl", cntxt);
  const writable_props = [
    "element",
    "zIndex",
    "pointerEvents",
    "contextAttributes",
    "context",
    "fallback",
    "label",
    "labelledBy",
    "describedBy"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Webgl> was created with unknown prop '${key}'`);
  });
  function canvas_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(1, element2 = $$props2.element);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("contextAttributes" in $$props2)
      $$invalidate(10, contextAttributes = $$props2.contextAttributes);
    if ("context" in $$props2)
      $$invalidate(0, context = $$props2.context);
    if ("fallback" in $$props2)
      $$invalidate(4, fallback = $$props2.fallback);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(6, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(7, describedBy = $$props2.describedBy);
    if ("$$scope" in $$props2)
      $$invalidate(11, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    setContext,
    writable,
    element: element2,
    zIndex,
    pointerEvents,
    contextAttributes,
    context,
    fallback,
    label,
    labelledBy,
    describedBy,
    testGl,
    padding,
    cntxt,
    $padding
  });
  $$self.$inject_state = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(1, element2 = $$props2.element);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("contextAttributes" in $$props2)
      $$invalidate(10, contextAttributes = $$props2.contextAttributes);
    if ("context" in $$props2)
      $$invalidate(0, context = $$props2.context);
    if ("fallback" in $$props2)
      $$invalidate(4, fallback = $$props2.fallback);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(6, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(7, describedBy = $$props2.describedBy);
    if ("testGl" in $$props2)
      testGl = $$props2.testGl;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*context*/
    1) {
      $:
        cntxt.gl.set(context);
    }
  };
  return [
    context,
    element2,
    zIndex,
    pointerEvents,
    fallback,
    label,
    labelledBy,
    describedBy,
    $padding,
    padding,
    contextAttributes,
    $$scope,
    slots,
    canvas_binding
  ];
}
var Webgl = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      element: 1,
      zIndex: 2,
      pointerEvents: 3,
      contextAttributes: 10,
      context: 0,
      fallback: 4,
      label: 5,
      labelledBy: 6,
      describedBy: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Webgl",
      options,
      id: create_fragment6.name
    });
  }
  get element() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointerEvents() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointerEvents(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contextAttributes() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contextAttributes(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fallback() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fallback(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledBy() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledBy(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get describedBy() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set describedBy(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Webgl_default = Webgl;

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/lib/flatten.js
function flatten(list, accessor = (d) => d) {
  const acc = typeof accessor === "string" ? (d) => d[accessor] : accessor;
  if (Array.isArray(list) && Array.isArray(acc(list[0]))) {
    let flat = [];
    const l = list.length;
    for (let i = 0; i < l; i += 1) {
      flat = flat.concat(acc(list[i]));
    }
    return flat;
  }
  return list;
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/lib/uniques.js
function uniques(list, accessor, transform = true) {
  if (!Array.isArray(list)) {
    console.error("LayerCake error: Input value to `uniques` must be a list.");
    return null;
  }
  const ll = list.length;
  const iterater = typeof accessor === "function";
  const key = typeof accessor !== "undefined";
  const seen = /* @__PURE__ */ new Set();
  const result = [];
  for (let i = 0; i < ll; i += 1) {
    const d = list[i];
    const computed = iterater ? accessor(d) : key === true ? d[accessor] : d;
    if (!seen.has(computed)) {
      seen.add(computed);
      result.push(transform ? computed : d);
    }
  }
  return result;
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/lib/raise.js
function raise(el) {
  if (el.nextSibling)
    el.parentNode.appendChild(el);
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/lib/takeEvery.js
function takeEvery(list, n) {
  if (list.length <= n)
    return list;
  const e = Math.round(list.length / n);
  return list.filter((d, i) => {
    return i % e === 0;
  });
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/lib/bin.js
function bin2(data, value, { domain, thresholds } = {}) {
  if (typeof data !== "object") {
    throw new TypeError("The first argument of bin() must be an array or data object");
  }
  let hist = bin();
  if (value) {
    const acc = typeof value === "function" ? value : (d) => d[value];
    hist = hist.value(acc);
  }
  if (domain) {
    hist = hist.domain(domain);
  }
  if (thresholds) {
    hist = hist.thresholds(thresholds);
  }
  return hist(data);
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/lib/stack.js
function stack(data, keys, { value, order, offset } = {}) {
  if (typeof data !== "object") {
    throw new TypeError("The first argument of stack() must be an array or data object");
  }
  if (!Array.isArray(keys)) {
    throw new TypeError("The second argument of stack() must be an array of key names");
  }
  let stacker = stack_default().keys(keys);
  if (value) {
    stacker = stacker.value(value);
  }
  if (order) {
    stacker = stacker.order(order);
  }
  if (offset) {
    stacker = stacker.offset(offset);
  }
  return stacker(data);
}

// node_modules/.pnpm/layercake@8.4.0-beta.1_svelte@3.59.2_typescript@5.5.4/node_modules/layercake/dist/lib/groupLonger.js
function groupLonger(data, keys, { groupTo = "group", valueTo = "value", keepKeys = void 0 } = {}) {
  if (!Array.isArray(data)) {
    throw new TypeError("The first argument of groupLonger() must be an array of data");
  }
  if (!Array.isArray(keys)) {
    throw new TypeError("The second argument of groupLonger() must be an array of key names");
  }
  const keysSet = new Set(keys);
  const keep = keepKeys || Object.keys(data[0]).filter((d) => !keysSet.has(d));
  return keys.map((key) => {
    return {
      [groupTo]: key,
      values: data.map((d) => {
        return {
          ...Object.fromEntries(keep.map((k) => [k, d[k]])),
          [valueTo]: d[key],
          [groupTo]: key
        };
      })
    };
  });
}
export {
  Canvas_default as Canvas,
  Html_default as Html,
  LayerCake_default as LayerCake,
  ScaledSvg_default as ScaledSvg,
  Svg_default as Svg,
  Webgl_default as WebGL,
  bin2 as bin,
  calcExtents,
  flatten,
  groupLonger,
  raise,
  scaleCanvas_default as scaleCanvas,
  stack,
  takeEvery,
  uniques
};
//# sourceMappingURL=layercake.js.map
